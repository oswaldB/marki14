/**
 * √âtat Alpine.js pour la page impayes to-fix (contacts avec emails manquants)
 * G√®re la r√©cup√©ration des factures impay√©es depuis Parse et l'√©tat de la page
 */


// V√©rifier que le DOM est compl√®tement charg√© avant d'initialiser Alpine.js
document.addEventListener('DOMContentLoaded', () => {
  // Attendre que Alpine.js soit disponible
  const checkAlpineReady = setInterval(() => {
    if (window.Alpine) {
      clearInterval(checkAlpineReady);
      
      // V√©rifier que l'√©l√©ment principal existe
      const mainElement = document.getElementById('toFixPage');
      if (mainElement) {
        initializeImpayesToFixState();
      } else {
        // Si l'√©l√©ment n'existe pas encore, attendre un peu et r√©essayer
        setTimeout(() => {
          if (document.getElementById('toFixPage')) {
            initializeImpayesToFixState();
          }
        }, 500);
      }
    }
  }, 100);
});

function initializeImpayesToFixState() {
  Alpine.data('impayesToFixState', () => ({
    
    // √âtat initial
    impayes: [],              // Donn√©es brutes des factures
    searchQuery: '',          // Texte de recherche
    viewMode: 'toFix',        // Mode d'affichage actuel
    isLoading: true,          // √âtat de chargement g√©n√©ral
    isLoadingSequences: false, // √âtat de chargement des s√©quences
    showPdfDrawer: false,     // √âtat du tiroir PDF
    showSequenceDrawer: false,// √âtat du tiroir de s√©quence
    currentInvoiceId: null,   // ID de la facture actuelle pour le visualiseur PDF
    currentPdfUrl: null,      // URL du PDF actuel
    currentPdfFilename: null, // Nom du fichier PDF actuel
    selectedImpaye: null,     // Facture s√©lectionn√©e pour la gestion des s√©quences
    sequences: [],            // Liste des s√©quences disponibles
    isSearching: false,      // √âtat de recherche en cours
    
    // Filtres sp√©cifiques √† la vue to-fix
    payerTypeFilter: '',     // Filtre par type de payeur
    delayFilter: '',         // Filtre par d√©lai (retard)
    amountFilter: '',        // Filtre par montant
    
    // Propri√©t√©s calcul√©es (getters)
    get filteredImpayes() {
      console.log('Calcul des factures filtr√©es pour la vue to-fix...');
      let result = [...this.impayes];
      
      // Appliquer le filtre de recherche texte
      if (this.searchQuery) {
        const query = this.searchQuery.toLowerCase();
        result = result.filter(invoice => {
          const invoiceText = JSON.stringify(invoice).toLowerCase();
          return invoiceText.includes(query);
        });
      }
      
      // Appliquer le filtre par type de payeur
      if (this.payerTypeFilter) {
        result = result.filter(invoice => {
          return invoice.payeur_type === this.payerTypeFilter;
        });
      }
      
      // Appliquer le filtre par d√©lai (retard)
      if (this.delayFilter) {
        const delayDays = parseInt(this.delayFilter);
        if (!isNaN(delayDays)) {
          result = result.filter(invoice => {
            const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
            return invoiceDelay >= delayDays;
          });
        }
      }
      
      // Appliquer le filtre par montant
      if (this.amountFilter) {
        const amountValue = parseFloat(this.amountFilter);
        if (!isNaN(amountValue)) {
          result = result.filter(invoice => {
            return (invoice.resteapayer || 0) >= amountValue;
          });
        }
      }
      
      return result;
    },
    
    get impayesToFix() {
      console.log('Filtrer les factures √† r√©parer (emails manquants)...');
      const toFix = this.filteredImpayes.filter(invoice => {
        return !invoice.payeur_email || 
               (invoice.apporteur_nom && !invoice.apporteur_email);
      });
      
      return toFix;
    },
    
    get contactsWithoutEmails() {
      console.log('Regroupement des contacts sans emails...');
      const contacts = new Map();
      
      this.filteredImpayes.forEach(invoice => {
        // V√©rifier les contacts sans email
        if (!invoice.payeur_email) {
          this.addInvoiceToContact(contacts, invoice.payeur_nom || 'Payeur Inconnu', invoice);
        }
        
        if (invoice.apporteur_nom && !invoice.apporteur_email) {
          this.addInvoiceToContact(contacts, invoice.apporteur_nom, invoice);
        }
      });
      
      // Convertir en tableau
      const contactsArray = Array.from(contacts.values());
      return contactsArray;
    },
    
    /**
     * Ajouter une facture √† un contact dans le regroupement
     * @param {Map} contacts - Map des contacts
     * @param {string} contactName - Nom du contact
     * @param {Object} invoice - Facture √† ajouter
     */
    addInvoiceToContact(contacts, contactName, invoice) {
      if (!contacts.has(contactName)) {
        contacts.set(contactName, {
          name: contactName,
          invoices: [],
          totalAmount: 0,
          maxDelay: 0
        });
      }
      
      const contact = contacts.get(contactName);
      contact.invoices.push(invoice);
      contact.totalAmount += invoice.resteapayer || 0;
      
      // Mettre √† jour le retard maximum
      const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
      if (invoiceDelay > contact.maxDelay) {
        contact.maxDelay = invoiceDelay;
      }
    },
    
    /**
     * Initialisation du composant
     */
    async init() {
      try {
        console.log('Initialisation de la page impayes to-fix...');
        this.isLoading = true;

        // Timeout de s√©curit√© pour √©viter que isLoading reste bloqu√© ind√©finiment
        const initTimeout = setTimeout(() => {
          console.error('‚ùå Timeout de l\'initialisation atteint (30 secondes)');
          this.isLoading = false;
          clearTimeout(initTimeout);
        }, 30000);

        // V√©rifier que Parse est disponible
        let parseRetryCount = 0;
        const maxParseRetries = 5;
        
        while (!window.Parse && parseRetryCount < maxParseRetries) {
          console.warn('‚ö†Ô∏è Parse n\'est pas encore disponible, attente... (tentative ' + (parseRetryCount + 1) + '/' + maxParseRetries + ')');
          await new Promise(resolve => setTimeout(resolve, 1000));
          parseRetryCount++;
        }

        if (!window.Parse) {
          console.error('‚ùå Parse n\'est pas disponible apr√®s ' + maxParseRetries + ' tentatives');
          this.isLoading = false;
          clearTimeout(initTimeout);
          return;
        }

        // D√©tecter le mode de vue bas√© sur l'URL
        this.detectViewModeFromUrl();

        // Charger les donn√©es
        await this.fetchImpayes();
        
        // Charger les s√©quences disponibles
        await this.fetchSequences();
        
        console.log('‚úÖ Initialisation termin√©e avec succ√®s');
        this.isLoading = false;
        clearTimeout(initTimeout);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation:', error);
        this.isLoading = false;
        clearTimeout(initTimeout);
        // R√©essayer apr√®s un court d√©lai, mais avec une limite
        if (this.initRetryCount < 3) {
          this.initRetryCount = (this.initRetryCount || 0) + 1;
          console.log('üîÑ Nouvelle tentative d\'initialisation (' + this.initRetryCount + '/3)...');
          setTimeout(() => this.init(), 2000);
        } else {
          console.error('‚ùå √âchec de l\'initialisation apr√®s 3 tentatives');
        }
      }
    },
    
    /**
     * D√©tecte le mode de vue bas√© sur l'URL actuelle
     */
    detectViewModeFromUrl() {
      const pathname = window.location.pathname;
      console.log('D√©tection du mode de vue depuis URL:', pathname);
      this.viewMode = 'toFix';
      console.log('Mode de vue d√©fini √†:', this.viewMode);
    },
    
    /**
     * R√©cup√®re les factures impay√©es depuis Parse
     */
    async fetchImpayes() {
      console.log('R√©cup√©ration des factures impay√©es depuis Parse...');
      
      try {
        this.isLoading = true;
        
        // Timeout de s√©curit√© pour la requ√™te
        const fetchTimeout = setTimeout(() => {
          console.error('‚ùå Timeout de la requ√™te fetchImpayes atteint (15 secondes)');
          this.isLoading = false;
        }, 15000);
        
        // Cr√©er une requ√™te pour les factures impay√©es
        const Impayes = Parse.Object.extend('Impayes');
        const query = new Parse.Query(Impayes);
        
        // Filtre: resteapayer != 0 et facturesoldee = false
        query.notEqualTo('resteapayer', 0);
        query.equalTo('facturesoldee', false);
        
        // Inclure les donn√©es de s√©quence si disponibles
        query.include('sequence');
        
        // Limite √† 99999 enregistrements
        query.limit(99999);
        
        // Ex√©cuter la requ√™te
        const results = await query.find();
        
        // Convertir les objets Parse en objets JavaScript simples
        this.impayes = results.map(item => {
          const json = item.toJSON();
          
          // Ajouter les informations de s√©quence si disponibles
          if (json.sequence && typeof json.sequence === 'object') {
            json.sequence_name = json.sequence.nom || 'Non sp√©cifi√©';
            json.sequence_is_automatic = json.sequence.is_automatic || false;
            json.sequence_id = json.sequence.objectId;
          } else {
            json.sequence_name = 'Sans s√©quence';
            json.sequence_is_automatic = false;
            json.sequence_id = null;
          }
          
          return json;
        });
        
        console.log(`‚úÖ ${this.impayes.length} factures impay√©es r√©cup√©r√©es`);
        if (this.impayes.length > 0) {
          console.log('üìÑ Exemple de facture:', this.impayes[0]);
        }
        
        clearTimeout(fetchTimeout);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des factures:', error);
        this.impayes = [];
        
        // Si c'est une erreur de r√©seau, essayer de recharger apr√®s un d√©lai
        if (error.message && (error.message.includes('network') || error.message.includes('ECONN'))) {
          console.log('üîÑ Nouvelle tentative de chargement des factures apr√®s erreur r√©seau...');
          setTimeout(() => this.fetchImpayes(), 5000);
        }
      } finally {
        this.isLoading = false;
        console.log('üîÑ Chargement des donn√©es termin√©');
      }
    },
    
    /**
     * Met √† jour la requ√™te de recherche
     */
    updateSearch() {
      console.log('Requ√™te de recherche mise √† jour:', this.searchQuery);
      console.log('üîç Nombre de r√©sultats filtr√©s:', this.filteredImpayes.length);
    },
    
    /**
     * Effectue la recherche avec loader
     */
    async performSearch() {
      console.log('üîç D√©but de la recherche:', this.searchQuery);
      
      try {
        this.isSearching = true;
        await new Promise(resolve => setTimeout(resolve, 500));
        console.log('‚úÖ Recherche termin√©e. R√©sultats:', this.filteredImpayes.length);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la recherche:', error);
      } finally {
        this.isSearching = false;
      }
    },
    
    /**
     * Mettre √† jour le filtre par type de payeur
     * @param {string} type - Type de payeur √† filtrer
     */
    setPayerTypeFilter(type) {
      console.log('üîç Filtre par type de payeur mis √† jour:', type);
      this.payerTypeFilter = type;
    },
    
    /**
     * Mettre √† jour le filtre par d√©lai
     * @param {string} delay - D√©lai minimum en jours
     */
    setDelayFilter(delay) {
      console.log('üîç Filtre par d√©lai mis √† jour:', delay);
      this.delayFilter = delay;
    },
    
    /**
     * Mettre √† jour le filtre par montant
     * @param {string} amount - Montant minimum
     */
    setAmountFilter(amount) {
      console.log('üîç Filtre par montant mis √† jour:', amount);
      this.amountFilter = amount;
    },
    
    /**
     * R√©initialiser tous les filtres
     */
    resetFilters() {
      console.log('üîç R√©initialisation de tous les filtres');
      this.searchQuery = '';
      this.payerTypeFilter = '';
      this.delayFilter = '';
      this.amountFilter = '';
    },
    
    /**
     * D√©tecter si l'appareil est mobile
     * @returns {boolean} True si l'appareil est mobile
     */
    isMobileDevice() {
      const userAgent = navigator.userAgent || navigator.vendor || window.opera;
      const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
      const isSmallScreen = window.innerWidth <= 768;
      return isMobile || isSmallScreen;
    },
    
    /**
     * Ouvrir le visualiseur PDF pour une facture
     * @param {string} invoiceId - L'ID de la facture
     */
    async openPdfViewer(invoiceId) {
      console.log('üìÑ Ouverture du visualiseur PDF pour la facture:', invoiceId);
      this.currentInvoiceId = invoiceId;
      
      try {
        const response = await Parse.Cloud.run('getInvoicePdf', { invoiceId });
        
        if (response.success && response.pdfData) {
          console.log('‚úÖ PDF r√©cup√©r√© avec succ√®s:', response.filename);
          const binaryString = atob(response.pdfData);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const blob = new Blob([bytes], { type: 'application/pdf' });
          this.currentPdfUrl = URL.createObjectURL(blob);
          this.currentPdfFilename = response.filename;
          
          if (this.isMobileDevice()) {
            console.log('üì± Appareil mobile d√©tect√© - ouverture du PDF dans un nouvel onglet');
            window.open(this.currentPdfUrl, '_blank');
            setTimeout(() => {
              if (this.currentPdfUrl && this.currentPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(this.currentPdfUrl);
              }
            }, 5000);
          } else {
            this.showPdfDrawer = true;
          }
        } else {
          console.warn('‚ö†Ô∏è Aucune donn√©e PDF trouv√©e:', response.message);
          this.currentPdfUrl = null;
          
          if (this.isMobileDevice()) {
            console.log('üì± Appareil mobile d√©tect√© - aucun PDF disponible');
            alert('Aucun PDF disponible pour cette facture');
          } else {
            this.showPdfDrawer = true;
          }
        }
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration du PDF:', error);
        this.currentPdfUrl = null;
        
        if (this.isMobileDevice()) {
          console.log('üì± Appareil mobile d√©tect√© - erreur de r√©cup√©ration du PDF');
          alert('Erreur lors de la r√©cup√©ration du PDF: ' + error.message);
        } else {
          this.showPdfDrawer = true;
        }
      }
    },
    
    /**
     * Fermer le visualiseur PDF
     */
    closePdfViewer() {
      console.log('üìÑ Fermeture du visualiseur PDF');
      if (this.currentPdfUrl && this.currentPdfUrl.startsWith('blob:')) {
        URL.revokeObjectURL(this.currentPdfUrl);
      }
      this.showPdfDrawer = false;
      this.currentInvoiceId = null;
      this.currentPdfUrl = null;
      this.currentPdfFilename = null;
    },
    
    /**
     * Calculer les jours de retard pour une facture
     * @param {Date} invoiceDate - La date de la facture
     * @returns {number} Jours de retard
     */
    calculateDaysOverdue(invoiceDate) {
      if (!invoiceDate) return 0;
      
      let invoiceDateObj;
      
      if (typeof invoiceDate === 'string') {
        invoiceDateObj = new Date(invoiceDate);
        
        if (isNaN(invoiceDateObj.getTime()) && invoiceDate.includes('/')) {
          const parts = invoiceDate.split('/');
          if (parts.length === 3) {
            invoiceDateObj = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
          }
        }
        
        if (isNaN(invoiceDateObj.getTime())) {
          invoiceDateObj = new Date(parseInt(invoiceDate));
        }
      } else if (typeof invoiceDate === 'number') {
        invoiceDateObj = new Date(invoiceDate);
      } else if (invoiceDate instanceof Date) {
        invoiceDateObj = invoiceDate;
      } else {
        if (invoiceDate.__type === 'Date' && invoiceDate.iso) {
          invoiceDateObj = new Date(invoiceDate.iso);
        } else {
          console.warn('‚ö†Ô∏è Format de date non reconnu:', invoiceDate);
          return 0;
        }
      }
      
      if (isNaN(invoiceDateObj.getTime())) {
        console.warn('‚ö†Ô∏è Date invalide:', invoiceDate);
        return 0;
      }
      
      const today = new Date();
      const diffTime = Math.abs(today - invoiceDateObj);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      console.log(`‚è∞ ${diffDays} jours de retard pour la facture dat√©e du ${invoiceDate}`);
      return diffDays;
    },
    
    /**
     * Formater une date pour l'affichage
     * @param {*} date - Date √† formater
     * @returns {string} Date format√©e
     */
    formatDate(date) {
      if (!date) return 'Date inconnue';
      
      let dateObj;
      
      if (typeof date === 'string') {
        dateObj = new Date(date);
        
        if (isNaN(dateObj.getTime()) && date.includes('/')) {
          const parts = date.split('/');
          if (parts.length === 3) {
            dateObj = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
          }
        }
      } else if (typeof date === 'number') {
        dateObj = new Date(date);
      } else if (date instanceof Date) {
        dateObj = date;
      } else {
        if (date.__type === 'Date' && date.iso) {
          dateObj = new Date(date.iso);
        } else {
          console.warn('‚ö†Ô∏è Format de date non reconnu:', date);
          return 'Date inconnue';
        }
      }
      
      if (isNaN(dateObj.getTime())) {
        console.warn('‚ö†Ô∏è Date invalide:', date);
        return 'Date inconnue';
      }
      
      return dateObj.toLocaleDateString('fr-FR');
    },
    
    /**
     * Formater une adresse compl√®te
     * @param {Object} invoice - La facture contenant les informations d'adresse
     * @returns {string} Adresse format√©e
     */
    formatAddress(invoice) {
      if (!invoice) return 'Adresse inconnue';
      
      const parts = [];
      
      if (invoice.numVoie) {
        parts.push(invoice.numVoie);
      }
      
      if (invoice.typeVoie) {
        parts.push(invoice.typeVoie);
      }
      
      if (invoice.cptAdresse) {
        parts.push(invoice.cptAdresse);
      }
      
      if (invoice.adresse) {
        parts.push(invoice.adresse);
      }
      
      if (invoice.numeroLot) {
        parts.push(`Lot ${invoice.numeroLot}`);
      }
      
      if (invoice.etage) {
        parts.push(`√âtage ${invoice.etage}`);
      }
      
      if (invoice.entree) {
        parts.push(`Entr√©e ${invoice.entree}`);
      }
      
      if (invoice.escalier) {
        parts.push(`Esc. ${invoice.escalier}`);
      }
      
      if (invoice.porte) {
        parts.push(`Porte ${invoice.porte}`);
      }
      
      if (invoice.codePostal || invoice.ville) {
        const postalCity = [];
        if (invoice.codePostal) {
          postalCity.push(invoice.codePostal);
        }
        if (invoice.ville) {
          postalCity.push(invoice.ville);
        }
        parts.push(postalCity.join(' '));
      }
      
      return parts.length > 0 ? parts.join(', ') : 'Adresse inconnue';
    },
    
    /**
     * Ouvrir le drawer de gestion des s√©quences
     * @param {Object} invoice - La facture √† g√©rer
     */
    async openSequenceDrawer(invoice) {
      if (invoice) {
        console.log('üìã Ouverture du drawer de s√©quence pour la facture:', invoice.nfacture);
      }
      this.selectedImpaye = invoice;
      
      if (this.sequences.length === 0) {
        console.log('üîÑ Les s√©quences ne sont pas charg√©es, chargement...');
        await this.fetchSequences();
      }
      
      this.showSequenceDrawer = true;
    },
    
    /**
     * Fermer le drawer de gestion des s√©quences
     */
    closeSequenceDrawer() {
      console.log('üìã Fermeture du drawer de s√©quence');
      this.showSequenceDrawer = false;
      this.selectedImpaye = null;
    },
    
    /**
     * R√©cup√©rer les s√©quences disponibles depuis Parse
     */
    async fetchSequences() {
      console.log('üîÑ R√©cup√©ration des s√©quences disponibles...');
      this.isLoadingSequences = true;
      
      try {
        const Sequence = Parse.Object.extend('Sequences');
        const query = new Parse.Query(Sequence);
        query.limit(1000);
        
        const results = await query.find();
        this.sequences = results.map(item => {
          const json = item.toJSON();
          return {
            id: json.objectId,
            name: json.nom || 'S√©quence sans nom',
            is_automatic: json.is_automatic || false,
            createdAt: json.createdAt
          };
        });
        
        console.log(`‚úÖ ${this.sequences.length} s√©quences r√©cup√©r√©es`);
        return this.sequences;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des s√©quences:', error);
        this.sequences = [];
        return [];
      } finally {
        this.isLoadingSequences = false;
      }
    },
    
    /**
     * Assigner une s√©quence √† une facture
     * @param {string} invoiceId - ID de la facture
     * @param {string} sequenceId - ID de la s√©quence
     */
    async assignSequenceToInvoice(invoiceId, sequenceId) {
      console.log(`üîó Assignment de la s√©quence ${sequenceId} √† la facture ${invoiceId}`);
      
      try {
        const Impayes = Parse.Object.extend('Impayes');
        const query = new Parse.Query(Impayes);
        query.equalTo('objectId', invoiceId);
        
        const invoice = await query.first();
        if (invoice) {
          if (sequenceId) {
            const Sequence = Parse.Object.extend('Sequences');
            const sequence = new Sequence();
            sequence.id = sequenceId;
            invoice.set('sequence', sequence);
          } else {
            invoice.unset('sequence');
          }
          
          await invoice.save();
          console.log(`‚úÖ S√©quence assign√©e avec succ√®s`);
          
          await this.fetchImpayes();
          return true;
        }
        
        return false;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'assignment de la s√©quence:', error);
        return false;
      }
    },
    
    /**
     * V√©rifier les emails manquants et d√©clencher la synchronisation
     */
    async verifyMissingEmails() {
      console.log('üîç V√©rification des emails manquants...');
      
      try {
        this.isLoading = true;
        
        // Appeler la fonction cloud syncImpayes pour forcer la synchronisation
        const response = await Parse.Cloud.run('syncImpayes');
        
        console.log('‚úÖ V√©rification termin√©e:', response);
        
        // Rafra√Æchir les donn√©es
        await this.fetchImpayes();
        
        return response;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification:', error);
        return null;
      } finally {
        this.isLoading = false;
      }
    },
    
    /**
     * Exporter les factures avec emails manquants au format CSV
     */
    exportMissingEmailsToCSV() {
      console.log('üì• Export des emails manquants au format CSV...');
      
      // Filtrer les factures avec emails manquants
      const missingEmails = this.impayes.filter(invoice => {
        return !invoice.payeur_email || 
               (invoice.apporteur_nom && !invoice.apporteur_email);
      });
      
      if (missingEmails.length === 0) {
        console.log('‚ö†Ô∏è Aucun email manquant trouv√©');
        return null;
      }
      
      // Cr√©er le contenu CSV
      const headers = ['Facture', 'Payeur', 'Email Payeur', 'Apporteur', 'Email Apporteur', 'Montant', 'Date'];
      const rows = missingEmails.map(invoice => [
        invoice.nfacture || '',
        invoice.payeur_nom || '',
        invoice.payeur_email || 'MANQUANT',
        invoice.apporteur_nom || '',
        invoice.apporteur_email || 'MANQUANT',
        invoice.resteapayer || 0,
        invoice.datepiece || ''
      ]);
      
      const csvContent = [headers, ...rows].map(row => row.join(';')).join('\n');
      
      // Cr√©er un blob et un lien de t√©l√©chargement
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', 'emails_manquants.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      console.log(`‚úÖ Export de ${missingEmails.length} factures avec emails manquants`);
      return csvContent;
    },
    
    /**
     * Copie les informations du contact dans le presse-papiers
     * @param {Object} contact - Objet contact avec les informations √† copier
     */
    copyContactInfo(contact) {
      if (!contact || !contact.name) {
        console.error('Contact invalide pour la copie');
        return;
      }
      
      const contactInfo = {
        Nom: contact.name,
        'Nombre de factures': contact.invoices.length,
        'Retard maximum': `${contact.maxDelay} jours`,
        'Total √† payer': contact.totalAmount.toLocaleString('fr-FR', {style: 'currency', currency: 'EUR'}),
        'Factures associ√©es': contact.invoices.map(invoice => `
  - Facture #${invoice.nfacture} (${invoice.resteapayer || 0}‚Ç¨, ${this.calculateDaysOverdue(invoice.datepiece)}j retard)`).join('')
      };
      
      const textToCopy = Object.entries(contactInfo)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n');
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        console.log(`‚úÖ Informations du contact "${contact.name}" copi√©es dans le presse-papiers`);
        // Afficher une notification √† l'utilisateur
        this.showTemporaryNotification(`Informations de ${contact.name} copi√©es !`);
      }).catch(err => {
        console.error('‚ùå √âchec de la copie dans le presse-papiers:', err);
        // M√©thode de secours pour les navigateurs qui ne supportent pas l'API clipboard
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed';
        document.body.appendChild(textarea);
        textarea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            console.log(`‚úÖ Informations du contact "${contact.name}" copi√©es avec la m√©thode de secours`);
            this.showTemporaryNotification(`Informations de ${contact.name} copi√©es !`);
          }
        } catch (fallbackErr) {
          console.error('‚ùå √âchec de la copie avec la m√©thode de secours:', fallbackErr);
        }
        
        document.body.removeChild(textarea);
      });
    },
    
    /**
     * Affiche une notification temporaire
     * @param {string} message - Message √† afficher
     */
    showTemporaryNotification(message) {
      // Cr√©er un √©l√©ment de notification
      const notification = document.createElement('div');
      notification.className = 'fixed bottom-4 right-4 bg-[#007ACE] text-white px-4 py-2 rounded-md shadow-lg z-50 transition-opacity duration-300';
      notification.textContent = message;
      notification.style.opacity = '0';
      
      document.body.appendChild(notification);
      
      // Animation d'apparition
      setTimeout(() => {
        notification.style.opacity = '1';
      }, 10);
      
      // Disparition apr√®s 3 secondes
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    },
    
    /**
     * Calculer les statistiques pour les cartes
     */
    get totalImpayesCount() {
      return this.filteredImpayes.length;
    },
    
    get totalAmount() {
      return this.filteredImpayes.reduce((total, invoice) => total + (invoice.resteapayer || 0), 0);
    },
    
    get averageDelay() {
      if (this.filteredImpayes.length === 0) return 0;
      const totalDelay = this.filteredImpayes.reduce((total, invoice) => {
        return total + this.calculateDaysOverdue(invoice.datepiece);
      }, 0);
      return Math.round(totalDelay / this.filteredImpayes.length);
    },
    
    get contactsToFixCount() {
      return this.contactsWithoutEmails.length;
    }
  }));

  // Initialiser automatiquement
  const state = Alpine.data('impayesToFixState');
  if (state && typeof state.init === 'function') {
    state.init();
  }
}