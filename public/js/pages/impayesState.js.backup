/**
 * √âtat Alpine.js pour la page impayes index (par payeur)
 * Version simplifi√©e et nettoy√©e
 */

document.addEventListener('alpine:init', () => {
  Alpine.data('impayesState', () => ({
    
    // √âtat initial
    impayes: [],              // Donn√©es brutes des factures
    searchQuery: '',          // Texte de recherche
    viewMode: 'byPayeur',     // Mode d'affichage actuel (par d√©faut: byPayeur)
    isLoading: true,          // √âtat de chargement g√©n√©ral
    isLoadingSequences: false, // √âtat de chargement des s√©quences
    showPdfDrawer: false,     // √âtat du tiroir PDF
    showSequenceDrawer: false,// √âtat du tiroir de s√©quence
    currentInvoiceId: null,   // ID de la facture actuelle pour le visualiseur PDF
    currentPdfUrl: null,      // URL du PDF actuel
    currentPdfFilename: null, // Nom du fichier PDF actuel
    draggedImpaye: null,      // Pour la fonctionnalit√© de glisser-d√©poser
    selectedImpaye: null,     // Facture s√©lectionn√©e pour la gestion des s√©quences
    selectedGroupInvoices: null, // Groupe de factures s√©lectionn√© pour l'assignation group√©e
    sequences: [],            // Liste des s√©quences disponibles
    newSequenceName: '',      // Nom de la nouvelle s√©quence
    newSequenceIsAutomatic: false, // Si la nouvelle s√©quence est automatique
    addingSequenceId: null,   // ID de la s√©quence en cours d'ajout (pour le spinner)
    sortBy: 'amount',         // Option de tri pour le regroupement par payeur (amount, delay, date)
    sortDirection: 'desc',    // Direction de tri (desc, asc)
    listSortBy: 'amount',     // Option de tri pour la vue liste (amount, delay, date)
    listSortDirection: 'desc',// Direction de tri pour la vue liste (desc, asc)

    actorSortBy: 'total',    // Option de tri pour la vue par acteur (total, name, count)
    actorSortDirection: 'desc', // Direction de tri pour la vue par acteur (desc, asc)
    isSearching: false,      // √âtat de recherche en cours
    
    // Nouveaux filtres
    payerTypeFilter: '',     // Filtre par type de payeur (Propri√©taire, Apporteur d'affaire, Autre)
    delayFilter: '',         // Filtre par d√©lai (retard)
    amountFilter: '',        // Filtre par montant
    
    // Propri√©t√©s calcul√©es (getters)
    get filteredImpayes() {
      console.log('Calcul des factures filtr√©es...');
      let result = this.sortedListImpayes;
      
      // Appliquer le filtre de recherche texte
      if (this.searchQuery) {
        const query = this.searchQuery.toLowerCase();
        result = result.filter(invoice => {
          const invoiceText = JSON.stringify(invoice).toLowerCase();
          return invoiceText.includes(query);
        });
      }
      
      // Appliquer le filtre par type de payeur
      if (this.payerTypeFilter) {
        result = result.filter(invoice => {
          return invoice.payeur_type === this.payerTypeFilter;
        });
      }
      
      // Appliquer le filtre par d√©lai (retard)
      if (this.delayFilter) {
        const delayDays = parseInt(this.delayFilter);
        if (!isNaN(delayDays)) {
          result = result.filter(invoice => {
            const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
            return invoiceDelay >= delayDays;
          });
        }
      }
      
      // Appliquer le filtre par montant
      if (this.amountFilter) {
        const amountValue = parseFloat(this.amountFilter);
        if (!isNaN(amountValue)) {
          result = result.filter(invoice => {
            return (invoice.resteapayer || 0) >= amountValue;
          });
        }
      }
      
      return result;
    },
    
    get sortedListImpayes() {
      console.log(`Tri des factures pour la vue liste (${this.listSortBy} ${this.listSortDirection})...`);
      
      return [...this.impayes].sort((a, b) => {
        let valueA, valueB;
        
        switch (this.listSortBy) {
          case 'delay': // Nombre de jours de retard
            valueA = this.calculateDaysOverdue(a.datepiece);
            valueB = this.calculateDaysOverdue(b.datepiece);
            break;
            
          case 'date': // Date de facture
            valueA = new Date(a.datepiece || 0).getTime();
            valueB = new Date(b.datepiece || 0).getTime();
            break;
            
          case 'amount': // Montant
          default:
            valueA = a.resteapayer || 0;
            valueB = b.resteapayer || 0;
            break;
        }
        
        // Appliquer la direction de tri
        if (this.listSortDirection === 'asc') {
          return valueA - valueB;
        } else {
          return valueB - valueA;
        }
      });
    },
    
    get impayesByPayeur() {
      console.log('Regroupement des factures par payeur avec regroupement par num√©ro de facture unique...');
      const grouped = {};
      const uniqueInvoices = new Map(); // Pour regrouper par num√©ro de facture unique (nfacture uniquement)
      
      // D'abord, regrouper toutes les factures par leur num√©ro de facture unique
      this.filteredImpayes.forEach(invoice => {
        const invoiceKey = invoice.nfacture; // Utiliser uniquement nfacture comme identifiant unique
        
        if (!uniqueInvoices.has(invoiceKey)) {
          uniqueInvoices.set(invoiceKey, invoice);
        } else {
          console.warn(`‚ö†Ô∏è Facture en double d√©tect√©e: ${invoice.nfacture} - conservation de la premi√®re occurrence`);
        }
      });
      
      // Ensuite, regrouper les factures uniques par payeur
      uniqueInvoices.forEach(invoice => {
        const payerName = invoice.payeur_nom || 'Inconnu';
        if (!grouped[payerName]) {
          grouped[payerName] = [];
        }
        grouped[payerName].push(invoice);
      });
      
      return grouped;
    },
    
    get sortedImpayesByPayeur() {
      console.log(`Tri des groupes par payeur (${this.sortBy} ${this.sortDirection})...`);
      const sorted = {};
      
      // Convertir l'objet group√© en tableau pour le tri
      const groups = Object.entries(this.impayesByPayeur);
      
      // Trier selon l'option s√©lectionn√©e
      groups.sort((a, b) => {
        const invoicesA = a[1];
        const invoicesB = b[1];
        
        let valueA, valueB;
        
        switch (this.sortBy) {
          case 'delay': // Nombre de jours de retard
            valueA = this.findMaxDelay(invoicesA);
            valueB = this.findMaxDelay(invoicesB);
            break;
          
          case 'date': // Date de la facture la plus r√©cente
            valueA = this.getLatestInvoiceDate(invoicesA);
            valueB = this.getLatestInvoiceDate(invoicesB);
            break;
          
          case 'amount': // Montant total
          default:
            valueA = this.calculateGroupTotal(invoicesA);
            valueB = this.calculateGroupTotal(invoicesB);
            break;
        }
        
        // Appliquer la direction de tri
        if (this.sortDirection === 'asc') {
          return valueA - valueB;
        } else {
          return valueB - valueA;
        }
      });
      
      // Reconvertir en objet
      groups.forEach(([payerName, invoices]) => {
        sorted[payerName] = invoices;
      });
      
      return sorted;
    },
    
    get impayesBySequence() {
      console.log('Regroupement des factures par s√©quence...');
      const grouped = {};
      
      // D'abord ajouter la cat√©gorie "Sans s√©quence"
      grouped['Sans s√©quence'] = this.filteredImpayes.filter(invoice => 
        !invoice.sequence_id || invoice.sequence_name === 'Sans s√©quence'
      );
      
      // Puis regrouper par s√©quence
      this.filteredImpayes.forEach(invoice => {
        if (invoice.sequence_id && invoice.sequence_name !== 'Sans s√©quence') {
          if (!grouped[invoice.sequence_name]) {
            grouped[invoice.sequence_name] = [];
          }
          grouped[invoice.sequence_name].push(invoice);
        }
      });
      
      return grouped;
    },
    
    get impayesByActor() {
      console.log('Regroupement des factures par acteur...');
      const grouped = {};
      
      // First, group invoices by invoice number to handle duplicates
      const invoicesByNumber = {};
      this.filteredImpayes.forEach(invoice => {
        const invoiceKey = invoice.nfacture;
        if (!invoicesByNumber[invoiceKey]) {
          invoicesByNumber[invoiceKey] = invoice;
        } else {
          console.warn(`‚ö†Ô∏è Facture en double d√©tect√©e: ${invoice.nfacture} - conservation de la premi√®re occurrence`);
        }
      });
      
      // Now process the unique invoices
      Object.values(invoicesByNumber).forEach(invoice => {
        // Regrouper par payeur pour "√† r√©gler"
        const payerName = invoice.payeur_nom || 'Inconnu';
        if (!grouped[payerName]) {
          grouped[payerName] = {
            toPay: [],
            broughtIn: []
          };
        }
        
        // Ajouter √† la liste "√† r√©gler" (toujours le cas pour les impay√©s)
        grouped[payerName].toPay.push(invoice);
        
        // Ajouter √† la liste "apport√©es" si apporteur existe
        if (invoice.apporteur_nom) {
          const providerName = invoice.apporteur_nom;
          if (!grouped[providerName]) {
            grouped[providerName] = {
              toPay: [],
              broughtIn: []
            };
          }
          grouped[providerName].broughtIn.push(invoice);
        }
      });
      
      return this.sortActors(grouped);
    },
    
    /**
     * Ajouter une facture √† un contact dans le regroupement
     * @param {Map} contacts - Map des contacts
     * @param {string} contactName - Nom du contact
     * @param {Object} invoice - Facture √† ajouter
     */
    addInvoiceToContact(contacts, contactName, invoice) {
      if (!contacts.has(contactName)) {
        contacts.set(contactName, {
          name: contactName,
          invoices: [],
          totalAmount: 0,
          maxDelay: 0
        });
      }
      
      const contact = contacts.get(contactName);
      contact.invoices.push(invoice);
      contact.totalAmount += invoice.resteapayer || 0;
      
      // Mettre √† jour le retard maximum
      const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
      if (invoiceDelay > contact.maxDelay) {
        contact.maxDelay = invoiceDelay;
      }
    },
    
    /**
     * Retourne les contacts sans emails (sans tri)
     * @param {Array} contacts - Liste des contacts
     * @returns {Array} Contacts non tri√©s
     */
    sortContactsWithoutEmails(contacts) {
      console.log('Retour des contacts sans emails (sans tri)...');
      return [...contacts]; // Retourne une copie sans tri
    },
    
    /**
     * Trier les acteurs
     * @param {Object} actors - Objet group√© par acteur
     * @returns {Object} Acteurs tri√©s
     */
    sortActors(actors) {
      console.log(`Tri des acteurs (${this.actorSortBy} ${this.actorSortDirection})...`);
      const sorted = {};
      
      // Convertir l'objet group√© en tableau pour le tri
      const actorEntries = Object.entries(actors);
      
      // Trier selon l'option s√©lectionn√©e
      actorEntries.sort((a, b) => {
        const [actorNameA, actorDataA] = a;
        const [actorNameB, actorDataB] = b;
        
        let valueA, valueB;
        
        switch (this.actorSortBy) {
          case 'name': // Nom de l'acteur
            valueA = actorNameA.toLowerCase();
            valueB = actorNameB.toLowerCase();
            break;
            
          case 'count': // Nombre total de factures
            valueA = actorDataA.toPay.length + actorDataA.broughtIn.length;
            valueB = actorDataB.toPay.length + actorDataB.broughtIn.length;
            break;
            
          case 'total': // Montant total
          default:
            valueA = this.calculateGroupTotal(actorDataA.toPay);
            valueB = this.calculateGroupTotal(actorDataB.toPay);
            break;
        }
        
        // Appliquer la direction de tri
        if (this.actorSortDirection === 'asc') {
          if (typeof valueA === 'string' && typeof valueB === 'string') {
            return valueA.localeCompare(valueB);
          } else {
            return valueA - valueB;
          }
        } else {
          if (typeof valueA === 'string' && typeof valueB === 'string') {
            return valueB.localeCompare(valueA);
          } else {
            return valueB - valueA;
          }
        }
      });
      
      // Reconvertir en objet
      actorEntries.forEach(([actorName, actorData]) => {
        sorted[actorName] = actorData;
      });
      
      return sorted;
    },
    
    get impayesToFix() {
      console.log('Filtrer les factures √† r√©parer...');
      const toFix = this.filteredImpayes.filter(invoice => {
        return !invoice.payeur_email || 
               (invoice.apporteur_nom && !invoice.apporteur_email);
      });
      
      // Retourner sans tri
      return toFix;
    },
    
    get contactsWithoutEmails() {
      console.log('Regroupement des contacts sans emails...');
      const contacts = new Map();
      
      this.filteredImpayes.forEach(invoice => {
        // V√©rifier les contacts sans email
        if (!invoice.payeur_email) {
          this.addInvoiceToContact(contacts, invoice.payeur_nom || 'Payeur Inconnu', invoice);
        }
        
        if (invoice.apporteur_nom && !invoice.apporteur_email) {
          this.addInvoiceToContact(contacts, invoice.apporteur_nom, invoice);
        }
      });
      
      // Convertir en tableau et appliquer le tri
      const contactsArray = Array.from(contacts.values());
      return this.sortContactsWithoutEmails(contactsArray);
    },
    
    

    
    /**
     * Initialisation du composant
     */
    async init() {
      try {
        console.log('Initialisation de la page impayes...');
        this.isLoading = true;

        // Timeout de s√©curit√© pour √©viter que isLoading reste bloqu√© ind√©finiment
        const initTimeout = setTimeout(() => {
          console.error('‚ùå Timeout de l\'initialisation atteint (30 secondes)');
          this.isLoading = false;
          clearTimeout(initTimeout);
        }, 30000);

        // V√©rifier que Parse est disponible
        let parseRetryCount = 0;
        const maxParseRetries = 5;
        
        while (!window.Parse && parseRetryCount < maxParseRetries) {
          console.warn('‚ö†Ô∏è Parse n\'est pas encore disponible, attente... (tentative ' + (parseRetryCount + 1) + '/' + maxParseRetries + ')');
          await new Promise(resolve => setTimeout(resolve, 1000));
          parseRetryCount++;
        }

        if (!window.Parse) {
          console.error('‚ùå Parse n\'est pas disponible apr√®s ' + maxParseRetries + ' tentatives');
          this.isLoading = false;
          clearTimeout(initTimeout);
          return;
        }

        // Parse est d√©j√† initialis√© dans BaseLayout, pas besoin de le r√©initialiser

        // D√©tecter le mode de vue bas√© sur l'URL
        this.detectViewModeFromUrl();

        // D'abord essayer de charger les donn√©es existantes depuis Parse
        // Cela √©vite une synchronisation co√ªteuse si les donn√©es sont d√©j√† disponibles
        await this.fetchImpayes();
        
        // Charger les s√©quences disponibles
        await this.fetchSequences();
        
        console.log('‚úÖ Initialisation termin√©e avec succ√®s');
        this.isLoading = false;
        clearTimeout(initTimeout);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'initialisation:', error);
        this.isLoading = false;
        clearTimeout(initTimeout);
        // R√©essayer apr√®s un court d√©lai, mais avec une limite
        if (this.initRetryCount < 3) {
          this.initRetryCount = (this.initRetryCount || 0) + 1;
          console.log('üîÑ Nouvelle tentative d\'initialisation (' + this.initRetryCount + '/3)...');
          setTimeout(() => this.init(), 2000);
        } else {
          console.error('‚ùå √âchec de l\'initialisation apr√®s 3 tentatives');
        }
      }
    },
    
    /**
     * D√©tecte le mode de vue bas√© sur l'URL actuelle
     */
    detectViewModeFromUrl() {
      const pathname = window.location.pathname;
      console.log('D√©tection du mode de vue depuis URL:', pathname);
      
      // Mapper les chemins aux modes de vue
      const pathToViewMode = {
        '/impayes/': 'byPayeur',
        '/impayes/list': 'list',
        '/impayes/sequence': 'sequence',
        '/impayes/by-actor': 'byActor',
        '/impayes/to-fix': 'toFix',
        '/impayes/stats': 'stats'
      };
      
      // Trouver le mode de vue correspondant ou utiliser le mode par d√©faut
      this.viewMode = pathToViewMode[pathname] || 'byPayeur';
      console.log('Mode de vue d√©fini √†:', this.viewMode);
    },
    
    /**
     * Synchronise les donn√©es depuis PostgreSQL vers Parse
     */
    async syncImpayesFromPostgres() {
      console.log('Synchronisation des donn√©es depuis PostgreSQL...');
      
      try {
        this.isLoading = true;
        
        // Appeler la fonction cloud syncImpayes
        const response = await Parse.Cloud.run('syncImpayes');
        
        console.log('‚úÖ Synchronisation termin√©e:', response);
        
        // Apr√®s la synchronisation, r√©cup√©rer les donn√©es mises √† jour
        await this.fetchImpayes();
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la synchronisation:', error);
        // M√™me en cas d'erreur de synchronisation, essayer de r√©cup√©rer les donn√©es existantes
        await this.fetchImpayes();
      }
    },
    
    /**
     * R√©cup√®re les factures impay√©es depuis Parse
     */
    async fetchImpayes() {
      console.log('R√©cup√©ration des factures impay√©es depuis Parse...');
      
      try {
        this.isLoading = true;
        
        // Timeout de s√©curit√© pour la requ√™te
        const fetchTimeout = setTimeout(() => {
          console.error('‚ùå Timeout de la requ√™te fetchImpayes atteint (15 secondes)');
          this.isLoading = false;
        }, 15000);
        
        // Cr√©er une requ√™te pour les factures impay√©es - Utiliser "Impayes" avec un "s"
        const Impayes = Parse.Object.extend('Impayes');
        const query = new Parse.Query(Impayes);
        
        // Filtre: resteapayer != 0 et facturesoldee = false
        query.notEqualTo('resteapayer', 0);
        query.equalTo('facturesoldee', false);
        
        // Inclure les donn√©es de s√©quence si disponibles
        query.include('sequence');
        
        // Limite √† 99999 enregistrements comme sp√©cifi√©
        query.limit(99999);
        
        // Ex√©cuter la requ√™te
        const results = await query.find();
        
        // Convertir les objets Parse en objets JavaScript simples
        this.impayes = results.map(item => {
          const json = item.toJSON();
          
          // Ajouter les informations de s√©quence si disponibles
          if (json.sequence && typeof json.sequence === 'object') {
            json.sequence_name = json.sequence.nom || 'Non sp√©cifi√©';
            json.sequence_is_automatic = json.sequence.is_automatic || false;
            json.sequence_id = json.sequence.objectId;
          } else {
            json.sequence_name = 'Sans s√©quence';
            json.sequence_is_automatic = false;
            json.sequence_id = null;
          }
          
          return json;
        });
        
        // Pagination removed as per requirements
        
        console.log(`‚úÖ ${this.impayes.length} factures impay√©es r√©cup√©r√©es`);
        if (this.impayes.length > 0) {
          console.log('üìÑ Exemple de facture:', this.impayes[0]);
        }
        
        clearTimeout(fetchTimeout);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des factures:', error);
        this.impayes = [];
        // Pagination removed as per requirements
        
        // Si c'est une erreur de r√©seau, essayer de recharger apr√®s un d√©lai
        if (error.message && (error.message.includes('network') || error.message.includes('ECONN'))) {
          console.log('üîÑ Nouvelle tentative de chargement des factures apr√®s erreur r√©seau...');
          setTimeout(() => this.fetchImpayes(), 5000);
        }
      } finally {
        this.isLoading = false;
        console.log('üîÑ Chargement des donn√©es termin√©');
      }
    },
    
    /**
     * D√©finit le mode d'affichage actuel
     * @param {string} mode - Le mode d'affichage √† d√©finir
     */
    setViewMode(mode) {
      console.log('Changement de mode d\'affichage:', mode);
      this.viewMode = mode;
      
      // Logs de d√©bogage pour v√©rifier l'√©tat
      console.log('üìä √âtat actuel apr√®s changement de mode:', {
        viewMode: this.viewMode,
        impayesCount: this.impayes.length,
        filteredCount: this.filteredImpayes.length
      });
    },
    
    /**
     * Met √† jour la requ√™te de recherche avec debouncing
     */
    updateSearch() {
      console.log('Requ√™te de recherche mise √† jour:', this.searchQuery);
      
      // Le filtrage r√©el est g√©r√© par la propri√©t√© calcul√©e
      console.log('üîç Nombre de r√©sultats filtr√©s:', this.filteredImpayes.length);
    },
    
    /**
     * Effectue la recherche avec loader
     */
    async performSearch() {
      console.log('üîç D√©but de la recherche:', this.searchQuery);
      
      try {
        this.isSearching = true;
        
        // Simuler un d√©lai de recherche (remplacer par une vraie recherche API si n√©cessaire)
        await new Promise(resolve => setTimeout(resolve, 500));
        
        console.log('‚úÖ Recherche termin√©e. R√©sultats:', this.filteredImpayes.length);
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la recherche:', error);
      } finally {
        this.isSearching = false;
      }
    },
    
    /**
     * Changer l'option de tri
     * @param {string} sortBy - Option de tri (total, delay, amount)
     */
    setSortBy(sortBy) {
      console.log('Changement de l\'option de tri:', sortBy);
      this.sortBy = sortBy;
      console.log('üìä Tri mis √† jour:', {
        sortBy: this.sortBy,
        sortDirection: this.sortDirection
      });
    },
    
    /**
     * Changer la direction de tri
     * @param {string} direction - Direction de tri (asc, desc)
     */
    setSortDirection(direction) {
      console.log('Changement de la direction de tri:', direction);
      this.sortDirection = direction;
      console.log('üìä Tri mis √† jour:', {
        sortBy: this.sortBy,
        sortDirection: this.sortDirection
      });
    },
    
    /**
     * Basculer la direction de tri
     */
    toggleSortDirection() {
      this.sortDirection = this.sortDirection === 'asc' ? 'desc' : 'asc';
      console.log('üìä Direction de tri bascul√©e:', this.sortDirection);
    },
    
    /**
     * Changer l'option de tri pour la vue liste
     * @param {string} sortBy - Option de tri (amount, delay, date)
     */
    setListSortBy(sortBy) {
      console.log('Changement de l\'option de tri pour la vue liste:', sortBy);
      this.listSortBy = sortBy;
      console.log('üìä Tri de la vue liste mis √† jour:', {
        listSortBy: this.listSortBy,
        listSortDirection: this.listSortDirection
      });
    },
    
    /**
     * Basculer la direction de tri pour la vue liste
     */
    toggleListSortDirection() {
      this.listSortDirection = this.listSortDirection === 'asc' ? 'desc' : 'asc';
      console.log('üìä Direction de tri de la vue liste bascul√©e:', this.listSortDirection);
    },
    

    
    /**
     * Changer l'option de tri pour la vue par acteur
     * @param {string} sortBy - Option de tri (total, name, count)
     */
    setActorSortBy(sortBy) {
      console.log('Changement de l\'option de tri pour la vue par acteur:', sortBy);
      this.actorSortBy = sortBy;
      console.log('üìä Tri de la vue par acteur mis √† jour:', {
        actorSortBy: this.actorSortBy,
        actorSortDirection: this.actorSortDirection
      });
    },
    
    /**
     * Basculer la direction de tri pour la vue par acteur
     */
    toggleActorSortDirection() {
      this.actorSortDirection = this.actorSortDirection === 'asc' ? 'desc' : 'asc';
      console.log('üìä Direction de tri de la vue par acteur bascul√©e:', this.actorSortDirection);
    },
    
    /**
     * Mettre √† jour le filtre par type de payeur
     * @param {string} type - Type de payeur √† filtrer
     */
    setPayerTypeFilter(type) {
      console.log('üîç Filtre par type de payeur mis √† jour:', type);
      this.payerTypeFilter = type;
    },
    
    /**
     * Mettre √† jour le filtre par d√©lai
     * @param {string} delay - D√©lai minimum en jours
     */
    setDelayFilter(delay) {
      console.log('üîç Filtre par d√©lai mis √† jour:', delay);
      this.delayFilter = delay;
    },
    
    /**
     * Mettre √† jour le filtre par montant
     * @param {string} amount - Montant minimum
     */
    setAmountFilter(amount) {
      console.log('üîç Filtre par montant mis √† jour:', amount);
      this.amountFilter = amount;
    },
    
    /**
     * R√©initialiser tous les filtres
     */
    resetFilters() {
      console.log('üîç R√©initialisation de tous les filtres');
      this.searchQuery = '';
      this.payerTypeFilter = '';
      this.delayFilter = '';
      this.amountFilter = '';
    },
    

    
    /**
     * D√©tecter si l'appareil est mobile
     * @returns {boolean} True si l'appareil est mobile
     */
    isMobileDevice() {
      // V√©rifier la largeur de l'√©cran et l'agent utilisateur
      const userAgent = navigator.userAgent || navigator.vendor || window.opera;
      const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());
      const isSmallScreen = window.innerWidth <= 768; // md breakpoint
      
      return isMobile || isSmallScreen;
    },
    
    /**
     * Ouvrir le visualiseur PDF pour une facture
     * @param {string} invoiceId - L'ID de la facture
     */
    async openPdfViewer(invoiceId) {
      console.log('üìÑ Ouverture du visualiseur PDF pour la facture:', invoiceId);
      this.currentInvoiceId = invoiceId;
      
      try {
        // Appeler la fonction cloud pour r√©cup√©rer le PDF
        const response = await Parse.Cloud.run('getInvoicePdf', { invoiceId });
        
        if (response.success && response.pdfData) {
          console.log('‚úÖ PDF r√©cup√©r√© avec succ√®s:', response.filename);
          // Cr√©er un blob URL pour le PDF
          const binaryString = atob(response.pdfData);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          const blob = new Blob([bytes], { type: 'application/pdf' });
          this.currentPdfUrl = URL.createObjectURL(blob);
          this.currentPdfFilename = response.filename;
          
          // Sur mobile, ouvrir dans un nouvel onglet
          if (this.isMobileDevice()) {
            console.log('üì± Appareil mobile d√©tect√© - ouverture du PDF dans un nouvel onglet');
            window.open(this.currentPdfUrl, '_blank');
            // Nettoyer le blob URL apr√®s un court d√©lai
            setTimeout(() => {
              if (this.currentPdfUrl && this.currentPdfUrl.startsWith('blob:')) {
                URL.revokeObjectURL(this.currentPdfUrl);
              }
            }, 5000);
          } else {
            // Sur desktop, afficher le drawer
            this.showPdfDrawer = true;
          }
        } else {
          console.warn('‚ö†Ô∏è Aucune donn√©e PDF trouv√©e:', response.message);
          if (response.pdfPath) {
            console.warn('Chemin PDF trouv√© mais t√©l√©chargement √©chou√©:', response.pdfPath);
          }
          this.currentPdfUrl = null;
          
          // Sur mobile, afficher un message ou ouvrir une page vide
          if (this.isMobileDevice()) {
            console.log('üì± Appareil mobile d√©tect√© - aucun PDF disponible');
            alert('Aucun PDF disponible pour cette facture');
          } else {
            this.showPdfDrawer = true;
          }
        }
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration du PDF:', error);
        this.currentPdfUrl = null;
        
        // Sur mobile, afficher un message d'erreur
        if (this.isMobileDevice()) {
          console.log('üì± Appareil mobile d√©tect√© - erreur de r√©cup√©ration du PDF');
          alert('Erreur lors de la r√©cup√©ration du PDF: ' + error.message);
        } else {
          this.showPdfDrawer = true;
        }
      }
    },
    
    /**
     * Fermer le visualiseur PDF
     */
    closePdfViewer() {
      console.log('üìÑ Fermeture du visualiseur PDF');
      // Nettoyer le blob URL si n√©cessaire
      if (this.currentPdfUrl && this.currentPdfUrl.startsWith('blob:')) {
        URL.revokeObjectURL(this.currentPdfUrl);
      }
      this.showPdfDrawer = false;
      this.currentInvoiceId = null;
      this.currentPdfUrl = null;
      this.currentPdfFilename = null;
    },
    
    /**
     * Calculer les jours de retard pour une facture
     * @param {Date} invoiceDate - La date de la facture
     * @returns {number} Jours de retard
     */
    calculateDaysOverdue(invoiceDate) {
      if (!invoiceDate) return 0;
      
      let invoiceDateObj;
      
      // Handle different date formats
      if (typeof invoiceDate === 'string') {
        // Try ISO format first
        invoiceDateObj = new Date(invoiceDate);
        
        // If that fails, try parsing as DD/MM/YYYY
        if (isNaN(invoiceDateObj.getTime()) && invoiceDate.includes('/')) {
          const parts = invoiceDate.split('/');
          if (parts.length === 3) {
            invoiceDateObj = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
          }
        }
        
        // If still invalid, try parsing as timestamp
        if (isNaN(invoiceDateObj.getTime())) {
          invoiceDateObj = new Date(parseInt(invoiceDate));
        }
      } else if (typeof invoiceDate === 'number') {
        // Handle timestamp
        invoiceDateObj = new Date(invoiceDate);
      } else if (invoiceDate instanceof Date) {
        // Already a Date object
        invoiceDateObj = invoiceDate;
      } else {
        // Handle Parse Date objects
        if (invoiceDate.__type === 'Date' && invoiceDate.iso) {
          invoiceDateObj = new Date(invoiceDate.iso);
        } else {
          console.warn('‚ö†Ô∏è Format de date non reconnu:', invoiceDate);
          return 0;
        }
      }
      
      // Check if date is valid
      if (isNaN(invoiceDateObj.getTime())) {
        console.warn('‚ö†Ô∏è Date invalide:', invoiceDate);
        return 0;
      }
      
      const today = new Date();
      const diffTime = Math.abs(today - invoiceDateObj);
      const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
      
      console.log(`‚è∞ ${diffDays} jours de retard pour la facture dat√©e du ${invoiceDate}`);
      return diffDays;
    },
    
    /**
     * Formater une date pour l'affichage
     * @param {*} date - Date √† formater
     * @returns {string} Date format√©e
     */
    formatDate(date) {
      if (!date) return 'Date inconnue';
      
      let dateObj;
      
      // Handle different date formats
      if (typeof date === 'string') {
        dateObj = new Date(date);
        
        // If that fails, try parsing as DD/MM/YYYY
        if (isNaN(dateObj.getTime()) && date.includes('/')) {
          const parts = date.split('/');
          if (parts.length === 3) {
            dateObj = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
          }
        }
      } else if (typeof date === 'number') {
        // Handle timestamp
        dateObj = new Date(date);
      } else if (date instanceof Date) {
        // Already a Date object
        dateObj = date;
      } else {
        // Handle Parse Date objects
        if (date.__type === 'Date' && date.iso) {
          dateObj = new Date(date.iso);
        } else {
          console.warn('‚ö†Ô∏è Format de date non reconnu:', date);
          return 'Date inconnue';
        }
      }
      
      // Check if date is valid
      if (isNaN(dateObj.getTime())) {
        console.warn('‚ö†Ô∏è Date invalide:', date);
        return 'Date inconnue';
      }
      
      return dateObj.toLocaleDateString('fr-FR');
    },
    
    /**
     * Tronquer du texte √† une longueur maximale
     * @param {string} text - Texte √† tronquer
     * @param {number} maxLength - Longueur maximale (240 par d√©faut)
     * @returns {string} Texte tronqu√©
     */
    truncateText(text, maxLength = 240) {
      if (!text) return '';
      
      if (text.length <= maxLength) {
        return text;
      }
      
      return text.substring(0, maxLength) + '...';
    },
    
    /**
     * Formater une adresse compl√®te
     * @param {Object} invoice - La facture contenant les informations d'adresse
     * @returns {string} Adresse format√©e
     */
    formatAddress(invoice) {
      if (!invoice) return 'Adresse inconnue';
      
      const parts = [];
      
      // Ajouter le num√©ro et type de voie
      if (invoice.numVoie) {
        parts.push(invoice.numVoie);
      }
      
      if (invoice.typeVoie) {
        parts.push(invoice.typeVoie);
      }
      
      // Ajouter le compl√©ment d'adresse
      if (invoice.cptAdresse) {
        parts.push(invoice.cptAdresse);
      }
      
      // Ajouter l'adresse principale
      if (invoice.adresse) {
        parts.push(invoice.adresse);
      }
      
      // Ajouter le num√©ro de lot, √©tage, entr√©e, escalier, porte
      if (invoice.numeroLot) {
        parts.push(`Lot ${invoice.numeroLot}`);
      }
      
      if (invoice.etage) {
        parts.push(`√âtage ${invoice.etage}`);
      }
      
      if (invoice.entree) {
        parts.push(`Entr√©e ${invoice.entree}`);
      }
      
      if (invoice.escalier) {
        parts.push(`Esc. ${invoice.escalier}`);
      }
      
      if (invoice.porte) {
        parts.push(`Porte ${invoice.porte}`);
      }
      
      // Ajouter code postal et ville
      if (invoice.codePostal || invoice.ville) {
        const postalCity = [];
        if (invoice.codePostal) {
          postalCity.push(invoice.codePostal);
        }
        if (invoice.ville) {
          postalCity.push(invoice.ville);
        }
        parts.push(postalCity.join(' '));
      }
      
      return parts.length > 0 ? parts.join(', ') : 'Adresse inconnue';
    },
    
    /**
     * Formater la date d'intervention
     * @param {*} date - Date d'intervention
     * @returns {string} Date format√©e
     */
    formatInterventionDate(date) {
      return this.formatDate(date);
    },
    
    /**
     * Calculer le total pour un groupe de factures
     * @param {Array} invoices - Liste de factures
     * @returns {number} Total
     */
    calculateGroupTotal(invoices) {
      if (!invoices || !Array.isArray(invoices)) return 0;
      return invoices.reduce((total, invoice) => total + (invoice.resteapayer || 0), 0);
    },
    
    /**
     * Trouver le retard maximum pour un groupe de factures
     * @param {Array} invoices - Liste de factures
     * @returns {number} Retard maximum en jours
     */
    findMaxDelay(invoices) {
      if (!invoices || !Array.isArray(invoices) || invoices.length === 0) return 0;
      
      const delays = invoices.map(invoice => this.calculateDaysOverdue(invoice.datepiece));
      return Math.max(...delays);
    },
    
    /**
     * Obtenir la date de la facture la plus r√©cente pour un groupe
     * @param {Array} invoices - Liste de factures
     * @returns {number} Timestamp de la date la plus r√©cente
     */
    getLatestInvoiceDate(invoices) {
      if (!invoices || !Array.isArray(invoices) || invoices.length === 0) return 0;
      
      const dates = invoices.map(invoice => {
        let dateObj;
        if (typeof invoice.datepiece === 'string') {
          dateObj = new Date(invoice.datepiece);
        } else if (typeof invoice.datepiece === 'number') {
          dateObj = new Date(invoice.datepiece);
        } else if (invoice.datepiece instanceof Date) {
          dateObj = invoice.datepiece;
        } else if (invoice.datepiece?.__type === 'Date' && invoice.datepiece.iso) {
          dateObj = new Date(invoice.datepiece.iso);
        } else {
          dateObj = new Date(0);
        }
        
        return isNaN(dateObj.getTime()) ? 0 : dateObj.getTime();
      });
      
      return Math.max(...dates);
    },
    
    /**
     * Obtenir les s√©quences uniques pour un groupe de factures
     * @param {Array} invoices - Liste de factures
     * @returns {Array} Liste de s√©quences uniques
     */
    getUniqueSequences(invoices) {
      if (!invoices || !Array.isArray(invoices) || invoices.length === 0) return [];
      
      const uniqueSequences = new Map();
      invoices.forEach(invoice => {
        if (invoice.sequence_name && !uniqueSequences.has(invoice.sequence_name)) {
          uniqueSequences.set(invoice.sequence_name, {
            name: invoice.sequence_name,
            is_automatic: invoice.sequence_is_automatic
          });
        }
      });
      
      return Array.from(uniqueSequences.values());
    },
    
    /**
     * Ouvrir le drawer de gestion des s√©quences
     * @param {Object} invoice - La facture √† g√©rer
     * @param {Array} groupInvoices - Optionnel: groupe de factures pour l'assignation group√©e
     */
    async openSequenceDrawer(invoice, groupInvoices = null) {
      if (invoice) {
        console.log('üìã Ouverture du drawer de s√©quence pour la facture:', invoice.nfacture);
      } else {
        console.log('üìã Ouverture du drawer de s√©quence pour attribution group√©e');
      }
      this.selectedImpaye = invoice;
      this.selectedGroupInvoices = groupInvoices; // Stocker le groupe pour l'assignation group√©e
      
      // Si les s√©quences ne sont pas encore charg√©es ou si on veut les rafra√Æchir
      if (this.sequences.length === 0) {
        console.log('üîÑ Les s√©quences ne sont pas charg√©es, chargement...');
        await this.fetchSequences();
      }
      
      this.showSequenceDrawer = true;
    },
    
    /**
     * Assigner une s√©quence √† un groupe de factures
     * @param {Array} invoices - Liste des factures
     * @param {string} sequenceId - ID de la s√©quence
     */
    async assignSequenceToGroup(invoices, sequenceId) {
      console.log(`üîó Assignment de la s√©quence ${sequenceId} √† ${invoices.length} factures`);
      
      try {
        this.addingSequenceId = sequenceId;
        
        const Impayes = Parse.Object.extend('Impayes');
        
        // Assigner la s√©quence √† chaque facture du groupe
        for (const invoice of invoices) {
          const query = new Parse.Query(Impayes);
          query.equalTo('objectId', invoice.objectId);
          
          const invoiceToUpdate = await query.first();
          if (invoiceToUpdate) {
            if (sequenceId) {
              const Sequence = Parse.Object.extend('Sequences');
              const sequence = new Sequence();
              sequence.id = sequenceId;
              invoiceToUpdate.set('sequence', sequence);
            } else {
              invoiceToUpdate.unset('sequence');
            }
            
            await invoiceToUpdate.save();
          }
        }
        
        console.log(`‚úÖ S√©quence assign√©e avec succ√®s √† ${invoices.length} factures`);
        
        // Rafra√Æchir les donn√©es
        await this.fetchImpayes();
        return true;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'assignment de la s√©quence au groupe:', error);
        return false;
      } finally {
        this.addingSequenceId = null;
      }
    },
    
    /**
     * Fermer le drawer de gestion des s√©quences
     */
    closeSequenceDrawer() {
      console.log('üìã Fermeture du drawer de s√©quence');
      this.showSequenceDrawer = false;
      this.selectedImpaye = null;
    },
    
    /**
     * R√©cup√©rer les s√©quences disponibles depuis Parse
     */
    async fetchSequences() {
      console.log('üîÑ R√©cup√©ration des s√©quences disponibles...');
      this.isLoadingSequences = true;
      
      try {
        const Sequence = Parse.Object.extend('Sequences');
        const query = new Parse.Query(Sequence);
        query.limit(1000);
        
        const results = await query.find();
        this.sequences = results.map(item => {
          const json = item.toJSON();
          return {
            id: json.objectId,
            name: json.nom || 'S√©quence sans nom',
            is_automatic: json.is_automatic || false,
            createdAt: json.createdAt
          };
        });
        
        console.log(`‚úÖ ${this.sequences.length} s√©quences r√©cup√©r√©es`);
        console.log('üìã S√©quences disponibles:', this.sequences.map(s => ({ id: s.id, name: s.name })));
        return this.sequences;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des s√©quences:', error);
        this.sequences = [];
        return [];
      } finally {
        this.isLoadingSequences = false;
      }
    },
    
    /**
     * Assigner une s√©quence √† une facture
     * @param {string} invoiceId - ID de la facture
     * @param {string} sequenceId - ID de la s√©quence
     */
    async assignSequenceToInvoice(invoiceId, sequenceId) {
      console.log(`üîó Assignment de la s√©quence ${sequenceId} √† la facture ${invoiceId}`);
      
      try {
        this.addingSequenceId = sequenceId;
        
        const Impayes = Parse.Object.extend('Impayes');
        const query = new Parse.Query(Impayes);
        query.equalTo('objectId', invoiceId);
        
        const invoice = await query.first();
        if (invoice) {
          if (sequenceId) {
            const Sequence = Parse.Object.extend('Sequences');
            const sequence = new Sequence();
            sequence.id = sequenceId;
            invoice.set('sequence', sequence);
          } else {
            invoice.unset('sequence');
          }
          
          await invoice.save();
          console.log(`‚úÖ S√©quence assign√©e avec succ√®s`);
          
          // Rafra√Æchir les donn√©es
          await this.fetchImpayes();
          return true;
        }
        
        return false;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de l\'assignment de la s√©quence:', error);
        return false;
      } finally {
        this.addingSequenceId = null;
      }
    },
    
    /**
     * Cr√©er une nouvelle s√©quence
     * @param {string} name - Nom de la s√©quence
     * @param {boolean} isAutomatic - Si la s√©quence est automatique
     */
    async createSequence(name, isAutomatic = false) {
      console.log(`üìã Cr√©ation d'une nouvelle s√©quence: ${name}`);
      
      try {
        const Sequence = Parse.Object.extend('Sequences');
        const newSequence = new Sequence();
        
        newSequence.set('nom', name);
        newSequence.set('is_automatic', isAutomatic);
        
        const savedSequence = await newSequence.save();
        console.log(`‚úÖ S√©quence cr√©√©e avec succ√®s: ${savedSequence.id}`);
        
        // Rafra√Æchir la liste des s√©quences
        await this.fetchSequences();
        return savedSequence.toJSON();
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la cr√©ation de la s√©quence:', error);
        return null;
      }
    },
    
    /**
     * V√©rifier les emails manquants et d√©clencher la synchronisation
     */
    async verifyMissingEmails() {
      console.log('üîç V√©rification des emails manquants...');
      
      try {
        this.isLoading = true;
        
        // Appeler la fonction cloud syncImpayes pour forcer la synchronisation
        const response = await Parse.Cloud.run('syncImpayes');
        
        console.log('‚úÖ V√©rification termin√©e:', response);
        
        // Rafra√Æchir les donn√©es
        await this.fetchImpayes();
        
        return response;
        
      } catch (error) {
        console.error('‚ùå Erreur lors de la v√©rification:', error);
        return null;
      } finally {
        this.isLoading = false;
      }
    },
    
    /**
     * Exporter les factures avec emails manquants au format CSV
     */
    exportMissingEmailsToCSV() {
      console.log('üì• Export des emails manquants au format CSV...');
      
      // Filtrer les factures avec emails manquants
      const missingEmails = this.impayes.filter(invoice => {
        return !invoice.payeur_email || 
               (invoice.apporteur_nom && !invoice.apporteur_email);
      });
      
      if (missingEmails.length === 0) {
        console.log('‚ö†Ô∏è Aucun email manquant trouv√©');
        return null;
      }
      
      // Cr√©er le contenu CSV
      const headers = ['Facture', 'Payeur', 'Email Payeur', 'Apporteur', 'Email Apporteur', 'Montant', 'Date'];
      const rows = missingEmails.map(invoice => [
        invoice.nfacture || '',
        invoice.payeur_nom || '',
        invoice.payeur_email || 'MANQUANT',
        invoice.apporteur_nom || '',
        invoice.apporteur_email || 'MANQUANT',
        invoice.resteapayer || 0,
        invoice.datepiece || ''
      ]);
      
      const csvContent = [headers, ...rows].map(row => row.join(';')).join('\n');
      
      // Cr√©er un blob et un lien de t√©l√©chargement
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.setAttribute('href', url);
      link.setAttribute('download', 'emails_manquants.csv');
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      console.log(`‚úÖ Export de ${missingEmails.length} factures avec emails manquants`);
      return csvContent;
    },
    
    /**
     * Copie les informations du contact dans le presse-papiers
     * @param {Object} contact - Objet contact avec les informations √† copier
     */
    copyContactInfo(contact) {
      if (!contact || !contact.name) {
        console.error('Contact invalide pour la copie');
        return;
      }
      
      const contactInfo = {
        Nom: contact.name,
        'Nombre de factures': contact.invoices.length,
        'Retard maximum': `${contact.maxDelay} jours`,
        'Total √† payer': contact.totalAmount.toLocaleString('fr-FR', {style: 'currency', currency: 'EUR'}),
        'Factures associ√©es': contact.invoices.map(invoice => `
  - Facture #${invoice.nfacture} (${invoice.resteapayer || 0}‚Ç¨, ${this.calculateDaysOverdue(invoice.datepiece)}j retard)`).join('')
      };
      
      const textToCopy = Object.entries(contactInfo)
        .map(([key, value]) => `${key}: ${value}`)
        .join('\n');
      
      navigator.clipboard.writeText(textToCopy).then(() => {
        console.log(`‚úÖ Informations du contact "${contact.name}" copi√©es dans le presse-papiers`);
        // Afficher une notification √† l'utilisateur
        this.showTemporaryNotification(`Informations de ${contact.name} copi√©es !`);
      }).catch(err => {
        console.error('‚ùå √âchec de la copie dans le presse-papiers:', err);
        // M√©thode de secours pour les navigateurs qui ne supportent pas l'API clipboard
        const textarea = document.createElement('textarea');
        textarea.value = textToCopy;
        textarea.style.position = 'fixed';
        document.body.appendChild(textarea);
        textarea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            console.log(`‚úÖ Informations du contact "${contact.name}" copi√©es avec la m√©thode de secours`);
            this.showTemporaryNotification(`Informations de ${contact.name} copi√©es !`);
          }
        } catch (fallbackErr) {
          console.error('‚ùå √âchec de la copie avec la m√©thode de secours:', fallbackErr);
        }
        
        document.body.removeChild(textarea);
      });
    },
    
    /**
     * Affiche une notification temporaire
     * @param {string} message - Message √† afficher
     */
    showTemporaryNotification(message) {
      // Cr√©er un √©l√©ment de notification
      const notification = document.createElement('div');
      notification.className = 'fixed bottom-4 right-4 bg-[#007ACE] text-white px-4 py-2 rounded-md shadow-lg z-50 transition-opacity duration-300';
      notification.textContent = message;
      notification.style.opacity = '0';
      
      document.body.appendChild(notification);
      
      // Animation d'apparition
      setTimeout(() => {
        notification.style.opacity = '1';
      }, 10);
      
      // Disparition apr√®s 3 secondes
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    },
    
    /**
     * Calculer les statistiques pour les cartes
     */
    get totalImpayesCount() {
      return this.filteredImpayes.length;
    },
    
    get totalAmount() {
      return this.filteredImpayes.reduce((total, invoice) => total + (invoice.resteapayer || 0), 0);
    },
    
    get averageDelay() {
      if (this.filteredImpayes.length === 0) return 0;
      const totalDelay = this.filteredImpayes.reduce((total, invoice) => {
        return total + this.calculateDaysOverdue(invoice.datepiece);
      }, 0);
      return Math.round(totalDelay / this.filteredImpayes.length);
    },
    
    get contactsToFixCount() {
      return this.contactsWithoutEmails.length;
    },
    
    /**
     * Calculer le top 5 des payeurs par montant
     */
    get topPayeursByAmount() {
      const payersByAmount = [];
      
      // Regrouper les factures par payeur
      const payersMap = new Map();
      this.filteredImpayes.forEach(invoice => {
        const payerName = invoice.payeur_nom || 'Inconnu';
        if (!payersMap.has(payerName)) {
          payersMap.set(payerName, {
            name: payerName,
            amount: 0,
            delay: 0,
            invoiceCount: 0
          });
        }
        
        const payerData = payersMap.get(payerName);
        payerData.amount += invoice.resteapayer || 0;
        payerData.invoiceCount++;
        
        // Calculer le retard maximum pour ce payeur
        const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
        if (invoiceDelay > payerData.delay) {
          payerData.delay = invoiceDelay;
        }
      });
      
      // Convertir en tableau et trier par montant
      const payersArray = Array.from(payersMap.values());
      payersArray.sort((a, b) => b.amount - a.amount);
      
      // Retourner les 5 premiers
      return payersArray.slice(0, 5);
    },
    
    /**
     * Calculer le top 5 des payeurs par retard
     */
    get topPayeursByDelay() {
      const payersByDelay = [];
      
      // Regrouper les factures par payeur
      const payersMap = new Map();
      this.filteredImpayes.forEach(invoice => {
        const payerName = invoice.payeur_nom || 'Inconnu';
        if (!payersMap.has(payerName)) {
          payersMap.set(payerName, {
            name: payerName,
            amount: 0,
            delay: 0,
            invoiceCount: 0
          });
        }
        
        const payerData = payersMap.get(payerName);
        payerData.amount += invoice.resteapayer || 0;
        payerData.invoiceCount++;
        
        // Calculer le retard maximum pour ce payeur
        const invoiceDelay = this.calculateDaysOverdue(invoice.datepiece);
        if (invoiceDelay > payerData.delay) {
          payerData.delay = invoiceDelay;
        }
      });
      
      // Convertir en tableau et trier par retard
      const payersArray = Array.from(payersMap.values());
      payersArray.sort((a, b) => b.delay - a.delay);
      
      // Retourner les 5 premiers
      return payersArray.slice(0, 5);
    }
  }));
});
