---
export const prerender = true;

interface Props {
  title: string;
  withAuth?: boolean;
  hideSidebar?: boolean;
  Alpinefile?: string;}

const { title, withAuth = false, hideSidebar = false, Alpinefile } = Astro.props;

// Debug: Log the props to ensure they're being passed correctly
console.log('BaseLayout props:', { title, withAuth, hideSidebar });

import SideMenu from '../components/SideMenu.astro';
---

<!DOCTYPE html>
<html lang="fr" data-with-auth={withAuth}>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{title} — Marki</title>
  <!-- Set withAuth value for Alpine.js -->
  <script is:inline>
    // Read withAuth from data attribute and set it for Alpine.js
    document.addEventListener('DOMContentLoaded', function() {
      const htmlElement = document.documentElement;
      window.withAuthValue = htmlElement.getAttribute('data-with-auth') === 'true';
    });
  </script>

  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <style is:global>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
    [x-cloak] { display: none !important; }
  </style>
  <!-- Font Awesome via CDN -->
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />
  <!-- Approche REST: Parse Auth via Axios -->
  <script is:inline src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <script is:inline>
    // Configuration REST: Parse Auth (Axios)
    if (typeof window !== 'undefined') {
      // 1. Configurer Parse Auth via REST API (harmonisé avec parse-api.js)
      window.PARSE_AUTH_CONFIG = {
        appId: 'marki',
        restApiKey: 'Careless7-Gore4-Guileless0-Jogger5-Clubbed9',
        serverUrl: 'https://dev.parse.markidiags.com/',
        masterKey: null // Non utilisé côté client
      };
      console.log('✅ Parse REST configuré pour AUTH:', window.PARSE_AUTH_CONFIG.serverUrl);
      
      // 2. Fonctions utilitaires Parse REST
      window.ParseRest = {
        async becomeSession(sessionToken) {
          try {
            const response = await axios.get(`${window.PARSE_AUTH_CONFIG.serverUrl}/users/me`, {
              headers: {
                'X-Parse-Application-Id': window.PARSE_AUTH_CONFIG.appId,
                'X-Parse-REST-API-Key': window.PARSE_AUTH_CONFIG.restApiKey,
                'X-Parse-Session-Token': sessionToken
              }
            });
            return {
              user: response.data,
              sessionToken: sessionToken // Le token reste le même pour REST
            };
          } catch (error) {
            console.error('❌ Erreur Parse REST becomeSession:', error.response?.data || error.message);
            throw error;
          }
        }
      };
    }
  </script>
</head>
<body class="bg-gray-50">
  <!-- Vérification d'authentification avec Alpine.js -->
  <div x-data="{ withAuth: window.withAuthValue }" x-init="
    if (withAuth) {
      const authStore = Alpine.store('auth');
      if (authStore && typeof authStore.checkAuth === 'function') {
        authStore.checkAuth(true, window.location.pathname);
      }
    }
  "></div>
  


  
  <!-- Script d'authentification conditionnel (ancien système) -->
  <script is:inline>
    // Code d'authentification - uniquement côté client
    if (typeof window !== 'undefined') {
      // S'assurer que withAuth est défini et est un booléen
      const authEnabled = Boolean(window.withAuthValue) && window.location.pathname !== '/login';
      console.log('Authentification:', authEnabled ? 'activée' : 'désactivée');
      
      if (authEnabled) {
        window.addEventListener('DOMContentLoaded', async () => {
          // Attendre que Parse REST soit complètement initialisé (pour AUTH)
          await new Promise(resolve => {
            if (typeof window.ParseRest !== 'undefined' && window.PARSE_AUTH_CONFIG) {
              resolve();
            } else {
              const checkParseRest = setInterval(() => {
                if (typeof window.ParseRest !== 'undefined' && window.PARSE_AUTH_CONFIG) {
                  clearInterval(checkParseRest);
                  resolve();
                }
              }, 50);
            }
          });

          const sessionToken = sessionStorage.getItem('parseSessionToken') || localStorage.getItem('parseSessionToken');
          const isPersistent = !!localStorage.getItem('parseSessionToken');

          if (sessionToken) {
            try {
              // Restaurer la session avec le token (Parse REST)
              const result = await window.ParseRest.becomeSession(sessionToken);
              const user = result.user; // Utilisation de la variable user
              const newToken = result.sessionToken; // Pour REST, le token ne change pas
              
              // Log des informations utilisateur pour le débogage
              console.log('✅ Utilisateur authentifié:', user?.username || 'Unknown');
              
              // Re-sauvegarder le token dans le bon stockage selon l'origine
              if (isPersistent) {
                localStorage.setItem('parseSessionToken', newToken);
                console.log('✅ Session persistante restaurée (Parse REST Auth)');
              } else {
                sessionStorage.setItem('parseSessionToken', newToken);
                console.log('✅ Session temporaire restaurée (Parse REST Auth)');
              }
              
              // Gestion de la redirection
              const currentPath = window.location.pathname;
              const redirectParam = new URLSearchParams(window.location.search).get('redirect');
              
              if (redirectParam && redirectParam !== currentPath) {
                console.log('✅ Redirection vers URL paramétrée:', redirectParam);
                window.location.href = redirectParam;
              } else if (currentPath === '/login') {
                console.log('✅ Redirection vers dashboard par défaut');
                window.location.href = '/dashboard';
              }
              
            } catch (error) {
              console.error('❌ Token invalide (Parse REST Auth):', error);
              // Supprimer le token invalide des deux stockages
              sessionStorage.removeItem('parseSessionToken');
              localStorage.removeItem('parseSessionToken');
              const currentPath = window.location.pathname;
              window.location.href = '/login?redirect=' + encodeURIComponent(currentPath);
            }
          } else {
            // Pas de token, redirection vers login
            const currentPath = window.location.pathname;
            window.location.href = '/login?redirect=' + encodeURIComponent(currentPath);
          }
        });
      }
    }
  </script>
  
  <!-- Vérification d'authentification via Alpine.js -->
  <div x-data="{ withAuth: window.withAuthValue }" x-init="
    if (withAuth) {
      const authStore = Alpine.store('auth');
      if (authStore && typeof authStore.checkAuth === 'function') {
        authStore.checkAuth(true, window.location.pathname);
      }
    }
  "></div>
  
  <!-- Script Alpine.js conditionnel -->
  {Alpinefile && (
    <script is:inline src={Alpinefile}></script>
  )}
  
  <!-- Chargement du state de login avec fallback amélioré -->
  <script>
    // Fallback amélioré pour loginState si le fichier ne charge pas
    window.loginState = window.loginState || function() {
      console.warn('loginState not loaded, using enhanced fallback');
      return {
        username: '',
        password: '',
        rememberMe: false,
        loading: false,
        error: null,
        
        async handleLogin() {
          this.loading = true;
          this.error = 'Login functionality is temporarily unavailable. Please try again later.';
          this.loading = false;
          console.error('Login functionality not available - missing loginState.js');
        },
        
        // Ajout de toutes les méthodes requises
        loginToParse: async function() {
          throw new Error('Parse login not available');
        },
        storeAuthToken: function(token, userId) {
          console.warn('Auth token storage not available');
        },
        redirectAfterLogin: function() {
          window.location.href = '/dashboard';
        },
        isSafeUrl: function(url) {
          return url.startsWith('/');
        },
        getErrorMessage: function(error) {
          return 'Login functionality is temporarily unavailable.';
        },
        init: function() {
          console.log('Fallback loginState initialized');
        }
      };
    };
  </script>
  <script src="/js/states/loginState.js" defer is:inline onerror="console.warn('Failed to load loginState.js, using fallback')"></script>
  
  <!-- Chargement des states Alpine.js avec meilleure gestion des erreurs -->
  <!-- Layout principal avec sidebar -->
  <div class="flex min-h-screen h-screen">
    <!-- Sidebar - conditionnellement affichée -->
    {hideSidebar ? null : (
      <aside class="w-80 bg-white border-r border-gray-200 hidden md:block flex-shrink-0 h-screen relative">
        <SideMenu />
      </aside>
    )}
    
    <!-- Contenu principal -->
    <main class={"flex-1 flex flex-col " + (hideSidebar ? " w-full" : "") + " overflow-y-auto pb-3 md:pb-0"}>
      <slot />
    </main>
  </div>
  
  <!-- Chargement du store auth global avec fallback amélioré -->
  <script>
    // Fallback amélioré pour authStore si le fichier ne charge pas
    window.authStoreFallback = {
      isAuthenticated: false,
      user: null,
      checkingAuth: false,
      
      async checkAuth(requireAuth = false, currentPath = '/') {
        console.warn('Auth store not loaded, using enhanced fallback');
        this.checkingAuth = true;
        
        try {
          // Vérification des données d'auth existentantes
          const authData = JSON.parse(localStorage.getItem('parseAuth')) ||
                          JSON.parse(sessionStorage.getItem('parseAuth'));
          
          if (authData && authData.parseToken) {
            this.isAuthenticated = true;
            this.user = { id: authData.userId };
            return true;
          }
          
          if (requireAuth) {
            window.location.href = `/login?redirect=${encodeURIComponent(currentPath)}`;
          }
          return false;
        } catch (error) {
          console.error('Fallback auth check error:', error);
          if (requireAuth) {
            window.location.href = `/login?redirect=${encodeURIComponent(currentPath)}`;
          }
          return false;
        } finally {
          this.checkingAuth = false;
        }
      },
      
      async validateToken(token) {
        console.warn('Token validation not available in fallback');
        return false;
      },
      
      redirectToLogin(redirectPath) {
        window.location.href = `/login?redirect=${encodeURIComponent(redirectPath)}`;
      },
      
      logout() {
        localStorage.removeItem('parseAuth');
        sessionStorage.removeItem('parseAuth');
        this.isAuthenticated = false;
        this.user = null;
        window.location.href = '/login';
      },
      
      clearAuthData() {
        localStorage.removeItem('parseAuth');
        sessionStorage.removeItem('parseAuth');
      },
      
      init() {
        console.log('Fallback auth store initialized');
      }
    };
    
    // S'assurer que Alpine.store('auth') existe
    document.addEventListener('alpine:init', () => {
      // @ts-ignore - Alpine is defined globally
      Alpine.store('auth', window.authStoreFallback);
    });
  </script>
  <script src="/js/states/authState.js" defer is:inline onerror="console.warn('Failed to load authState.js, using fallback')"></script>
  

  
</html>
