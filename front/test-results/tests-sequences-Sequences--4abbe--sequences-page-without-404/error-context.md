# Page snapshot

```yaml
- generic [ref=e4]:
  - generic [ref=e5]:
    - checkbox "Use dark theme" [ref=e6]
    - generic [ref=e7] [cursor=pointer]:
      - img [ref=e8]
      - img [ref=e12]
      - generic [ref=e16]: Use dark theme
  - banner [ref=e17]:
    - generic [ref=e18]:
      - heading "ReferenceError" [level=2] [ref=e19]
      - heading "An error occurred." [level=1] [ref=e20]
    - img [ref=e23]
  - generic [ref=e26]:
    - generic [ref=e27]:
      - img [ref=e29]
      - generic [ref=e31]: document is not defined
    - generic [ref=e32]:
      - img [ref=e34]
      - generic [ref=e36]:
        - text: Browser APIs are not available on the server. If the code is in a framework component, try to access these objects after rendering using lifecycle methods or use a
        - code [ref=e37]: client:only
        - text: directive to make the component exclusively run on the client. See
        - link "https://docs.astro.build/en/guides/troubleshooting/#document-or-window-is-not-defined" [ref=e38] [cursor=pointer]:
          - /url: https://docs.astro.build/en/guides/troubleshooting/#document-or-window-is-not-defined
        - text: for more information.
  - generic [ref=e39]:
    - generic [ref=e40]:
      - heading "node/module-runner.js:1070:6" [level=2] [ref=e41]
      - button "Open in editor" [ref=e43]:
        - text: Open in editor
        - img [ref=e44]
    - code [ref=e49]:
      - generic [ref=e50]: const VALID_ID_PREFIX = "/@id/", NULL_BYTE_PLACEHOLDER = "__x00__";
      - generic [ref=e51]: let SOURCEMAPPING_URL = "sourceMa";
      - generic [ref=e52]: SOURCEMAPPING_URL += "ppingURL";
      - generic [ref=e53]: const ERR_OUTDATED_OPTIMIZED_DEP = "ERR_OUTDATED_OPTIMIZED_DEP", isWindows = typeof process < "u" && process.platform === "win32";
      - generic [ref=e54]: "function unwrapId(id) {"
      - generic [ref=e55]: "return id.startsWith(VALID_ID_PREFIX) ? id.slice(VALID_ID_PREFIX.length).replace(NULL_BYTE_PLACEHOLDER, \"\\0\") : id;"
      - generic [ref=e56]: "}"
      - generic [ref=e57]: const windowsSlashRE = /\\/g;
      - generic [ref=e58]: "function slash(p) {"
      - generic [ref=e59]: return p.replace(windowsSlashRE, "/");
      - generic [ref=e60]: "}"
      - generic [ref=e61]: const postfixRE = /[?#].*$/;
      - generic [ref=e62]: "function cleanUrl(url) {"
      - generic [ref=e63]: return url.replace(postfixRE, "");
      - generic [ref=e64]: "}"
      - generic [ref=e65]: "function isPrimitive(value) {"
      - generic [ref=e66]: return !value || typeof value != "object" && typeof value != "function";
      - generic [ref=e67]: "}"
      - generic [ref=e68]: "const AsyncFunction = async function() {"
      - generic [ref=e69]: "}.constructor;"
      - generic [ref=e70]: let asyncFunctionDeclarationPaddingLineCount;
      - generic [ref=e71]: "function getAsyncFunctionDeclarationPaddingLineCount() {"
      - generic [ref=e72]: "if (typeof asyncFunctionDeclarationPaddingLineCount > \"u\") {"
      - generic [ref=e73]: const body = "/*code*/", source = new AsyncFunction("a", "b", body).toString();
      - generic [ref=e74]: "asyncFunctionDeclarationPaddingLineCount = source.slice(0, source.indexOf(body)).split(`"
      - generic [ref=e75]: "`).length - 1;"
      - generic [ref=e76]: "}"
      - generic [ref=e77]: return asyncFunctionDeclarationPaddingLineCount;
      - generic [ref=e78]: "}"
      - generic [ref=e79]: "function promiseWithResolvers() {"
      - generic [ref=e80]: let resolve2, reject;
      - generic [ref=e81]: "return { promise: new Promise((_resolve, _reject) => {"
      - generic [ref=e82]: resolve2 = _resolve, reject = _reject;
      - generic [ref=e83]: "}), resolve: resolve2, reject };"
      - generic [ref=e84]: "}"
      - generic [ref=e85]: const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
      - generic [ref=e86]: "function normalizeWindowsPath(input = \"\") {"
      - generic [ref=e87]: return input && input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
      - generic [ref=e88]: "}"
      - generic [ref=e89]: "const _IS_ABSOLUTE_RE = /^[/\\\\](?![/\\\\])|^[/\\\\]{2}(?!\\.)|^[A-Za-z]:[/\\\\]/, _DRIVE_LETTER_RE = /^[A-Za-z]:$/;"
      - generic [ref=e90]: "function cwd() {"
      - generic [ref=e91]: "return typeof process < \"u\" && typeof process.cwd == \"function\" ? process.cwd().replace(/\\\\/g, \"/\") : \"/\";"
      - generic [ref=e92]: "}"
      - generic [ref=e93]: "const resolve = function(...arguments_) {"
      - generic [ref=e94]: arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
      - generic [ref=e95]: let resolvedPath = "", resolvedAbsolute = !1;
      - generic [ref=e96]: "for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {"
      - generic [ref=e97]: "const path = index >= 0 ? arguments_[index] : cwd();"
      - generic [ref=e98]: "!path || path.length === 0 || (resolvedPath = `${path}/${resolvedPath}`, resolvedAbsolute = isAbsolute(path));"
      - generic [ref=e99]: "}"
      - generic [ref=e100]: "return resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute), resolvedAbsolute && !isAbsolute(resolvedPath) ? `/${resolvedPath}` : resolvedPath.length > 0 ? resolvedPath : \".\";"
      - generic [ref=e101]: "};"
      - generic [ref=e102]: "function normalizeString(path, allowAboveRoot) {"
      - generic [ref=e103]: let res = "", lastSegmentLength = 0, lastSlash = -1, dots = 0, char = null;
      - generic [ref=e104]: "for (let index = 0; index <= path.length; ++index) {"
      - generic [ref=e105]: if (index < path.length)
      - generic [ref=e106]: char = path[index];
      - generic [ref=e107]: "else {"
      - generic [ref=e108]: if (char === "/")
      - generic [ref=e109]: break;
      - generic [ref=e110]: char = "/";
      - generic [ref=e111]: "}"
      - generic [ref=e112]: "if (char === \"/\") {"
      - generic [ref=e113]: "if (!(lastSlash === index - 1 || dots === 1)) if (dots === 2) {"
      - generic [ref=e114]: "if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== \".\" || res[res.length - 2] !== \".\") {"
      - generic [ref=e115]: "if (res.length > 2) {"
      - generic [ref=e116]: const lastSlashIndex = res.lastIndexOf("/");
      - generic [ref=e117]: "lastSlashIndex === -1 ? (res = \"\", lastSegmentLength = 0) : (res = res.slice(0, lastSlashIndex), lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\")), lastSlash = index, dots = 0;"
      - generic [ref=e118]: continue;
      - generic [ref=e119]: "} else if (res.length > 0) {"
      - generic [ref=e120]: res = "", lastSegmentLength = 0, lastSlash = index, dots = 0;
      - generic [ref=e121]: continue;
      - generic [ref=e122]: "}"
      - generic [ref=e123]: "}"
      - generic [ref=e124]: "allowAboveRoot && (res += res.length > 0 ? \"/..\" : \"..\", lastSegmentLength = 2);"
      - generic [ref=e125]: "} else"
      - generic [ref=e126]: "res.length > 0 ? res += `/${path.slice(lastSlash + 1, index)}` : res = path.slice(lastSlash + 1, index), lastSegmentLength = index - lastSlash - 1;"
      - generic [ref=e127]: lastSlash = index, dots = 0;
      - generic [ref=e128]: "} else char === \".\" && dots !== -1 ? ++dots : dots = -1;"
      - generic [ref=e129]: "}"
      - generic [ref=e130]: return res;
      - generic [ref=e131]: "}"
      - generic [ref=e132]: "const isAbsolute = function(p) {"
      - generic [ref=e133]: return _IS_ABSOLUTE_RE.test(p);
      - generic [ref=e134]: "}, dirname = function(p) {"
      - generic [ref=e135]: const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
      - generic [ref=e136]: "return segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0]) && (segments[0] += \"/\"), segments.join(\"/\") || (isAbsolute(p) ? \"/\" : \".\");"
      - generic [ref=e137]: "}, decodeBase64 = typeof atob < \"u\" ? atob : (str) => Buffer.from(str, \"base64\").toString(\"utf-8\"), CHAR_FORWARD_SLASH = 47, CHAR_BACKWARD_SLASH = 92, percentRegEx = /%/g, backslashRegEx = /\\\\/g, newlineRegEx = /\\n/g, carriageReturnRegEx = /\\r/g, tabRegEx = /\\t/g, questionRegex = /\\?/g, hashRegex = /#/g;"
      - generic [ref=e138]: "function encodePathChars(filepath) {"
      - generic [ref=e139]: "return filepath.indexOf(\"%\") !== -1 && (filepath = filepath.replace(percentRegEx, \"%25\")), !isWindows && filepath.indexOf(\"\\\\\") !== -1 && (filepath = filepath.replace(backslashRegEx, \"%5C\")), filepath.indexOf(`"
      - generic [ref=e140]: "`) !== -1 && (filepath = filepath.replace(newlineRegEx, \"%0A\")), filepath.indexOf(\"\\r\") !== -1 && (filepath = filepath.replace(carriageReturnRegEx, \"%0D\")), filepath.indexOf(\" \") !== -1 && (filepath = filepath.replace(tabRegEx, \"%09\")), filepath;"
      - generic [ref=e141]: "}"
      - generic [ref=e142]: const posixDirname = dirname, posixResolve = resolve;
      - generic [ref=e143]: "function posixPathToFileHref(posixPath) {"
      - generic [ref=e144]: let resolved = posixResolve(posixPath);
      - generic [ref=e145]: const filePathLast = posixPath.charCodeAt(posixPath.length - 1);
      - generic [ref=e146]: "return (filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== \"/\" && (resolved += \"/\"), resolved = encodePathChars(resolved), resolved.indexOf(\"?\") !== -1 && (resolved = resolved.replace(questionRegex, \"%3F\")), resolved.indexOf(\"#\") !== -1 && (resolved = resolved.replace(hashRegex, \"%23\")), new URL(`file://${resolved}`).href;"
      - generic [ref=e147]: "}"
      - generic [ref=e148]: "function toWindowsPath(path) {"
      - generic [ref=e149]: return path.replace(/\//g, "\\");
      - generic [ref=e150]: "}"
      - generic [ref=e151]: const comma = 44, chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", intToChar = new Uint8Array(64), charToInt = new Uint8Array(128);
      - generic [ref=e152]: "for (let i = 0; i < chars.length; i++) {"
      - generic [ref=e153]: const c = chars.charCodeAt(i);
      - generic [ref=e154]: intToChar[i] = c, charToInt[c] = i;
      - generic [ref=e155]: "}"
      - generic [ref=e156]: "function decodeInteger(reader, relative) {"
      - generic [ref=e157]: let value = 0, shift = 0, integer = 0;
      - generic [ref=e158]: "do {"
      - generic [ref=e159]: const c = reader.next();
      - generic [ref=e160]: integer = charToInt[c], value |= (integer & 31) << shift, shift += 5;
      - generic [ref=e161]: "} while (integer & 32);"
      - generic [ref=e162]: const shouldNegate = value & 1;
      - generic [ref=e163]: return value >>>= 1, shouldNegate && (value = -2147483648 | -value), relative + value;
      - generic [ref=e164]: "}"
      - generic [ref=e165]: "function hasMoreVlq(reader, max) {"
      - generic [ref=e166]: "return reader.pos >= max ? !1 : reader.peek() !== comma;"
      - generic [ref=e167]: "}"
      - generic [ref=e168]: "class StringReader {"
      - generic [ref=e169]: "constructor(buffer) {"
      - generic [ref=e170]: this.pos = 0, this.buffer = buffer;
      - generic [ref=e171]: "}"
      - generic [ref=e172]: "next() {"
      - generic [ref=e173]: return this.buffer.charCodeAt(this.pos++);
      - generic [ref=e174]: "}"
      - generic [ref=e175]: "peek() {"
      - generic [ref=e176]: return this.buffer.charCodeAt(this.pos);
      - generic [ref=e177]: "}"
      - generic [ref=e178]: "indexOf(char) {"
      - generic [ref=e179]: "const { buffer, pos } = this, idx = buffer.indexOf(char, pos);"
      - generic [ref=e180]: "return idx === -1 ? buffer.length : idx;"
      - generic [ref=e181]: "}"
      - generic [ref=e182]: "}"
      - generic [ref=e183]: "function decode(mappings) {"
      - generic [ref=e184]: "const { length } = mappings, reader = new StringReader(mappings), decoded = [];"
      - generic [ref=e185]: let genColumn = 0, sourcesIndex = 0, sourceLine = 0, sourceColumn = 0, namesIndex = 0;
      - generic [ref=e186]: "do {"
      - generic [ref=e187]: const semi = reader.indexOf(";"), line = [];
      - generic [ref=e188]: let sorted = !0, lastCol = 0;
      - generic [ref=e189]: "for (genColumn = 0; reader.pos < semi; ) {"
      - generic [ref=e190]: let seg;
      - generic [ref=e191]: "genColumn = decodeInteger(reader, genColumn), genColumn < lastCol && (sorted = !1), lastCol = genColumn, hasMoreVlq(reader, semi) ? (sourcesIndex = decodeInteger(reader, sourcesIndex), sourceLine = decodeInteger(reader, sourceLine), sourceColumn = decodeInteger(reader, sourceColumn), hasMoreVlq(reader, semi) ? (namesIndex = decodeInteger(reader, namesIndex), seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]) : seg = [genColumn, sourcesIndex, sourceLine, sourceColumn]) : seg = [genColumn], line.push(seg), reader.pos++;"
      - generic [ref=e192]: "}"
      - generic [ref=e193]: sorted || sort(line), decoded.push(line), reader.pos = semi + 1;
      - generic [ref=e194]: "} while (reader.pos <= length);"
      - generic [ref=e195]: return decoded;
      - generic [ref=e196]: "}"
      - generic [ref=e197]: "function sort(line) {"
      - generic [ref=e198]: line.sort(sortComparator);
      - generic [ref=e199]: "}"
      - generic [ref=e200]: "function sortComparator(a, b) {"
      - generic [ref=e201]: return a[0] - b[0];
      - generic [ref=e202]: "}"
      - generic [ref=e203]: const COLUMN = 0, SOURCES_INDEX = 1, SOURCE_LINE = 2, SOURCE_COLUMN = 3, NAMES_INDEX = 4;
      - generic [ref=e204]: let found = !1;
      - generic [ref=e205]: "function binarySearch(haystack, needle, low, high) {"
      - generic [ref=e206]: "for (; low <= high; ) {"
      - generic [ref=e207]: const mid = low + (high - low >> 1), cmp = haystack[mid][COLUMN] - needle;
      - generic [ref=e208]: if (cmp === 0)
      - generic [ref=e209]: return found = !0, mid;
      - generic [ref=e210]: "cmp < 0 ? low = mid + 1 : high = mid - 1;"
      - generic [ref=e211]: "}"
      - generic [ref=e212]: return found = !1, low - 1;
      - generic [ref=e213]: "}"
      - generic [ref=e214]: "function upperBound(haystack, needle, index) {"
      - generic [ref=e215]: for (let i = index + 1; i < haystack.length && haystack[i][COLUMN] === needle; index = i++)
      - generic [ref=e216]: ;
      - generic [ref=e217]: return index;
      - generic [ref=e218]: "}"
      - generic [ref=e219]: "function lowerBound(haystack, needle, index) {"
      - generic [ref=e220]: for (let i = index - 1; i >= 0 && haystack[i][COLUMN] === needle; index = i--)
      - generic [ref=e221]: ;
      - generic [ref=e222]: return index;
      - generic [ref=e223]: "}"
      - generic [ref=e224]: "function memoizedBinarySearch(haystack, needle, state, key) {"
      - generic [ref=e225]: "const { lastKey, lastNeedle, lastIndex } = state;"
      - generic [ref=e226]: let low = 0, high = haystack.length - 1;
      - generic [ref=e227]: "if (key === lastKey) {"
      - generic [ref=e228]: if (needle === lastNeedle)
      - generic [ref=e229]: return found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle, lastIndex;
      - generic [ref=e230]: "needle >= lastNeedle ? low = lastIndex === -1 ? 0 : lastIndex : high = lastIndex;"
      - generic [ref=e231]: "}"
      - generic [ref=e232]: return state.lastKey = key, state.lastNeedle = needle, state.lastIndex = binarySearch(haystack, needle, low, high);
      - generic [ref=e233]: "}"
      - generic [ref=e234]: "const LINE_GTR_ZERO = \"`line` must be greater than 0 (lines start at line 1)\", COL_GTR_EQ_ZERO = \"`column` must be greater than or equal to 0 (columns start at column 0)\", LEAST_UPPER_BOUND = -1, GREATEST_LOWER_BOUND = 1;"
      - generic [ref=e235]: "function cast(map) {"
      - generic [ref=e236]: return map;
      - generic [ref=e237]: "}"
      - generic [ref=e238]: "function decodedMappings(map) {"
      - generic [ref=e239]: var _a;
      - generic [ref=e240]: return (_a = map)._decoded || (_a._decoded = decode(map._encoded));
      - generic [ref=e241]: "}"
      - generic [ref=e242]: "function originalPositionFor(map, needle) {"
      - generic [ref=e243]: "let { line, column, bias } = needle;"
      - generic [ref=e244]: if (line--, line < 0)
      - generic [ref=e245]: throw new Error(LINE_GTR_ZERO);
      - generic [ref=e246]: if (column < 0)
      - generic [ref=e247]: throw new Error(COL_GTR_EQ_ZERO);
      - generic [ref=e248]: const decoded = decodedMappings(map);
      - generic [ref=e249]: if (line >= decoded.length)
      - generic [ref=e250]: return OMapping(null, null, null, null);
      - generic [ref=e251]: const segments = decoded[line], index = traceSegmentInternal(segments, map._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
      - generic [ref=e252]: if (index === -1)
      - generic [ref=e253]: return OMapping(null, null, null, null);
      - generic [ref=e254]: const segment = segments[index];
      - generic [ref=e255]: if (segment.length === 1)
      - generic [ref=e256]: return OMapping(null, null, null, null);
      - generic [ref=e257]: "const { names, resolvedSources } = map;"
      - generic [ref=e258]: "return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);"
      - generic [ref=e259]: "}"
      - generic [ref=e260]: "function OMapping(source, line, column, name) {"
      - generic [ref=e261]: "return { source, line, column, name };"
      - generic [ref=e262]: "}"
      - generic [ref=e263]: "function traceSegmentInternal(segments, memo, line, column, bias) {"
      - generic [ref=e264]: let index = memoizedBinarySearch(segments, column, memo, line);
      - generic [ref=e265]: "return found ? index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index) : bias === LEAST_UPPER_BOUND && index++, index === -1 || index === segments.length ? -1 : index;"
      - generic [ref=e266]: "}"
      - generic [ref=e267]: "class DecodedMap {"
      - generic [ref=e268]: "constructor(map, from) {"
      - generic [ref=e269]: this.map = map;
      - generic [ref=e270]: "const { mappings, names, sources } = map;"
      - generic [ref=e271]: this.version = map.version, this.names = names || [], this._encoded = mappings || "", this._decodedMemo = memoizedState(), this.url = from, this.resolvedSources = (sources || []).map(
      - generic [ref=e272]: (s) => posixResolve(s || "", from)
      - generic [ref=e273]: );
      - generic [ref=e274]: "}"
      - generic [ref=e275]: _encoded;
      - generic [ref=e276]: _decoded;
      - generic [ref=e277]: _decodedMemo;
      - generic [ref=e278]: url;
      - generic [ref=e279]: version;
      - generic [ref=e280]: names = [];
      - generic [ref=e281]: resolvedSources;
      - generic [ref=e282]: "}"
      - generic [ref=e283]: "function memoizedState() {"
      - generic [ref=e284]: "return {"
      - generic [ref=e285]: "lastKey: -1,"
      - generic [ref=e286]: "lastNeedle: -1,"
      - generic [ref=e287]: "lastIndex: -1"
      - generic [ref=e288]: "};"
      - generic [ref=e289]: "}"
      - generic [ref=e290]: "function getOriginalPosition(map, needle) {"
      - generic [ref=e291]: const result = originalPositionFor(map, needle);
      - generic [ref=e292]: "return result.column == null ? null : result;"
      - generic [ref=e293]: "}"
      - generic [ref=e294]: const MODULE_RUNNER_SOURCEMAPPING_REGEXP = new RegExp(
      - generic [ref=e295]: "`//# ${SOURCEMAPPING_URL}=data:application/json;base64,(.+)`"
      - generic [ref=e296]: );
      - generic [ref=e297]: "class EvaluatedModuleNode {"
      - generic [ref=e298]: "constructor(id, url) {"
      - generic [ref=e299]: this.id = id, this.url = url, this.file = cleanUrl(id);
      - generic [ref=e300]: "}"
      - generic [ref=e301]: importers = /* @__PURE__ */ new Set();
      - generic [ref=e302]: imports = /* @__PURE__ */ new Set();
      - generic [ref=e303]: evaluated = !1;
      - generic [ref=e304]: meta;
      - generic [ref=e305]: promise;
      - generic [ref=e306]: exports;
      - generic [ref=e307]: file;
      - generic [ref=e308]: map;
      - generic [ref=e309]: "}"
      - generic [ref=e310]: "class EvaluatedModules {"
      - generic [ref=e311]: idToModuleMap = /* @__PURE__ */ new Map();
      - generic [ref=e312]: fileToModulesMap = /* @__PURE__ */ new Map();
      - generic [ref=e313]: urlToIdModuleMap = /* @__PURE__ */ new Map();
      - generic [ref=e314]: /**
      - generic [ref=e315]: "* Returns the module node by the resolved module ID. Usually, module ID is"
      - generic [ref=e316]: "* the file system path with query and/or hash. It can also be a virtual module."
      - generic [ref=e317]: "*"
      - generic [ref=e318]: "* Module runner graph will have 1 to 1 mapping with the server module graph."
      - generic [ref=e319]: "* @param id Resolved module ID"
      - generic [ref=e320]: "*/"
      - generic [ref=e321]: "getModuleById(id) {"
      - generic [ref=e322]: return this.idToModuleMap.get(id);
      - generic [ref=e323]: "}"
      - generic [ref=e324]: /**
      - generic [ref=e325]: "* Returns all modules related to the file system path. Different modules"
      - generic [ref=e326]: "* might have different query parameters or hash, so it's possible to have"
      - generic [ref=e327]: "* multiple modules for the same file."
      - generic [ref=e328]: "* @param file The file system path of the module"
      - generic [ref=e329]: "*/"
      - generic [ref=e330]: "getModulesByFile(file) {"
      - generic [ref=e331]: return this.fileToModulesMap.get(file);
      - generic [ref=e332]: "}"
      - generic [ref=e333]: /**
      - generic [ref=e334]: "* Returns the module node by the URL that was used in the import statement."
      - generic [ref=e335]: "* Unlike module graph on the server, the URL is not resolved and is used as is."
      - generic [ref=e336]: "* @param url Server URL that was used in the import statement"
      - generic [ref=e337]: "*/"
      - generic [ref=e338]: "getModuleByUrl(url) {"
      - generic [ref=e339]: return this.urlToIdModuleMap.get(unwrapId(url));
      - generic [ref=e340]: "}"
      - generic [ref=e341]: /**
      - generic [ref=e342]: "* Ensure that module is in the graph. If the module is already in the graph,"
      - generic [ref=e343]: "* it will return the existing module node. Otherwise, it will create a new"
      - generic [ref=e344]: "* module node and add it to the graph."
      - generic [ref=e345]: "* @param id Resolved module ID"
      - generic [ref=e346]: "* @param url URL that was used in the import statement"
      - generic [ref=e347]: "*/"
      - generic [ref=e348]: "ensureModule(id, url) {"
      - generic [ref=e349]: "if (id = normalizeModuleId(id), this.idToModuleMap.has(id)) {"
      - generic [ref=e350]: const moduleNode2 = this.idToModuleMap.get(id);
      - generic [ref=e351]: return this.urlToIdModuleMap.set(url, moduleNode2), moduleNode2;
      - generic [ref=e352]: "}"
      - generic [ref=e353]: const moduleNode = new EvaluatedModuleNode(id, url);
      - generic [ref=e354]: this.idToModuleMap.set(id, moduleNode), this.urlToIdModuleMap.set(url, moduleNode);
      - generic [ref=e355]: const fileModules = this.fileToModulesMap.get(moduleNode.file) || /* @__PURE__ */ new Set();
      - generic [ref=e356]: return fileModules.add(moduleNode), this.fileToModulesMap.set(moduleNode.file, fileModules), moduleNode;
      - generic [ref=e357]: "}"
      - generic [ref=e358]: "invalidateModule(node) {"
      - generic [ref=e359]: node.evaluated = !1, node.meta = void 0, node.map = void 0, node.promise = void 0, node.exports = void 0, node.imports.clear();
      - generic [ref=e360]: "}"
      - generic [ref=e361]: /**
      - generic [ref=e362]: "* Extracts the inlined source map from the module code and returns the decoded"
      - generic [ref=e363]: "* source map. If the source map is not inlined, it will return null."
      - generic [ref=e364]: "* @param id Resolved module ID"
      - generic [ref=e365]: "*/"
      - generic [ref=e366]: "getModuleSourceMapById(id) {"
      - generic [ref=e367]: const mod = this.getModuleById(id);
      - generic [ref=e368]: if (!mod) return null;
      - generic [ref=e369]: if (mod.map) return mod.map;
      - generic [ref=e370]: if (!mod.meta || !("code" in mod.meta)) return null;
      - generic [ref=e371]: const mapString = MODULE_RUNNER_SOURCEMAPPING_REGEXP.exec(
      - generic [ref=e372]: mod.meta.code
      - generic [ref=e373]: )?.[1];
      - generic [ref=e374]: "return mapString ? (mod.map = new DecodedMap(JSON.parse(decodeBase64(mapString)), mod.file), mod.map) : null;"
      - generic [ref=e375]: "}"
      - generic [ref=e376]: "clear() {"
      - generic [ref=e377]: this.idToModuleMap.clear(), this.fileToModulesMap.clear(), this.urlToIdModuleMap.clear();
      - generic [ref=e378]: "}"
      - generic [ref=e379]: "}"
      - generic [ref=e380]: const prefixedBuiltins = /* @__PURE__ */ new Set([
      - generic [ref=e381]: "\"node:sea\","
      - generic [ref=e382]: "\"node:sqlite\","
      - generic [ref=e383]: "\"node:test\","
      - generic [ref=e384]: "\"node:test/reporters\""
      - generic [ref=e385]: "]);"
      - generic [ref=e386]: "function normalizeModuleId(file) {"
      - generic [ref=e387]: "return prefixedBuiltins.has(file) ? file : slash(file).replace(/^\\/@fs\\//, isWindows ? \"\" : \"/\").replace(/^node:/, \"\").replace(/^\\/+/, \"/\").replace(/^file:\\//, \"/\");"
      - generic [ref=e388]: "}"
      - generic [ref=e389]: "class HMRContext {"
      - generic [ref=e390]: "constructor(hmrClient, ownerPath) {"
      - generic [ref=e391]: "this.hmrClient = hmrClient, this.ownerPath = ownerPath, hmrClient.dataMap.has(ownerPath) || hmrClient.dataMap.set(ownerPath, {});"
      - generic [ref=e392]: const mod = hmrClient.hotModulesMap.get(ownerPath);
      - generic [ref=e393]: mod && (mod.callbacks = []);
      - generic [ref=e394]: const staleListeners = hmrClient.ctxToListenersMap.get(ownerPath);
      - generic [ref=e395]: if (staleListeners)
      - generic [ref=e396]: "for (const [event, staleFns] of staleListeners) {"
      - generic [ref=e397]: const listeners = hmrClient.customListenersMap.get(event);
      - generic [ref=e398]: listeners && hmrClient.customListenersMap.set(
      - generic [ref=e399]: event,
      - generic [ref=e400]: listeners.filter((l) => !staleFns.includes(l))
      - generic [ref=e401]: );
      - generic [ref=e402]: "}"
      - generic [ref=e403]: this.newListeners = /* @__PURE__ */ new Map(), hmrClient.ctxToListenersMap.set(ownerPath, this.newListeners);
      - generic [ref=e404]: "}"
      - generic [ref=e405]: newListeners;
      - generic [ref=e406]: "get data() {"
      - generic [ref=e407]: return this.hmrClient.dataMap.get(this.ownerPath);
      - generic [ref=e408]: "}"
      - generic [ref=e409]: "accept(deps, callback) {"
      - generic [ref=e410]: if (typeof deps == "function" || !deps)
      - generic [ref=e411]: this.acceptDeps([this.ownerPath], ([mod]) => deps?.(mod));
      - generic [ref=e412]: else if (typeof deps == "string")
      - generic [ref=e413]: this.acceptDeps([deps], ([mod]) => callback?.(mod));
      - generic [ref=e414]: else if (Array.isArray(deps))
      - generic [ref=e415]: this.acceptDeps(deps, callback);
      - generic [ref=e416]: else
      - generic [ref=e417]: throw new Error("invalid hot.accept() usage.");
      - generic [ref=e418]: "}"
      - generic [ref=e419]: // export names (first arg) are irrelevant on the client side, they're
      - generic [ref=e420]: // extracted in the server for propagation
      - generic [ref=e421]: "acceptExports(_, callback) {"
      - generic [ref=e422]: this.acceptDeps([this.ownerPath], ([mod]) => callback?.(mod));
      - generic [ref=e423]: "}"
      - generic [ref=e424]: "dispose(cb) {"
      - generic [ref=e425]: this.hmrClient.disposeMap.set(this.ownerPath, cb);
      - generic [ref=e426]: "}"
      - generic [ref=e427]: "prune(cb) {"
      - generic [ref=e428]: this.hmrClient.pruneMap.set(this.ownerPath, cb);
      - generic [ref=e429]: "}"
      - generic [ref=e430]: // Kept for backward compatibility (#11036)
      - generic [ref=e431]: // eslint-disable-next-line @typescript-eslint/no-empty-function
      - generic [ref=e432]: "decline() {"
      - generic [ref=e433]: "}"
      - generic [ref=e434]: "invalidate(message) {"
      - generic [ref=e435]: const firstInvalidatedBy = this.hmrClient.currentFirstInvalidatedBy ?? this.ownerPath;
      - generic [ref=e436]: "this.hmrClient.notifyListeners(\"vite:invalidate\", {"
      - generic [ref=e437]: "path: this.ownerPath,"
      - generic [ref=e438]: message,
      - generic [ref=e439]: firstInvalidatedBy
      - generic [ref=e440]: "}), this.send(\"vite:invalidate\", {"
      - generic [ref=e441]: "path: this.ownerPath,"
      - generic [ref=e442]: message,
      - generic [ref=e443]: firstInvalidatedBy
      - generic [ref=e444]: "}), this.hmrClient.logger.debug("
      - generic [ref=e445]: "`invalidate ${this.ownerPath}${message ? `: ${message}` : \"\"}`"
      - generic [ref=e446]: );
      - generic [ref=e447]: "}"
      - generic [ref=e448]: "on(event, cb) {"
      - generic [ref=e449]: "const addToMap = (map) => {"
      - generic [ref=e450]: const existing = map.get(event) || [];
      - generic [ref=e451]: existing.push(cb), map.set(event, existing);
      - generic [ref=e452]: "};"
      - generic [ref=e453]: addToMap(this.hmrClient.customListenersMap), addToMap(this.newListeners);
      - generic [ref=e454]: "}"
      - generic [ref=e455]: "off(event, cb) {"
      - generic [ref=e456]: "const removeFromMap = (map) => {"
      - generic [ref=e457]: const existing = map.get(event);
      - generic [ref=e458]: if (existing === void 0)
      - generic [ref=e459]: return;
      - generic [ref=e460]: const pruned = existing.filter((l) => l !== cb);
      - generic [ref=e461]: "if (pruned.length === 0) {"
      - generic [ref=e462]: map.delete(event);
      - generic [ref=e463]: return;
      - generic [ref=e464]: "}"
      - generic [ref=e465]: map.set(event, pruned);
      - generic [ref=e466]: "};"
      - generic [ref=e467]: removeFromMap(this.hmrClient.customListenersMap), removeFromMap(this.newListeners);
      - generic [ref=e468]: "}"
      - generic [ref=e469]: "send(event, data) {"
      - generic [ref=e470]: "this.hmrClient.send({ type: \"custom\", event, data });"
      - generic [ref=e471]: "}"
      - generic [ref=e472]: "acceptDeps(deps, callback = () => {"
      - generic [ref=e473]: "}) {"
      - generic [ref=e474]: "const mod = this.hmrClient.hotModulesMap.get(this.ownerPath) || {"
      - generic [ref=e475]: "id: this.ownerPath,"
      - generic [ref=e476]: "callbacks: []"
      - generic [ref=e477]: "};"
      - generic [ref=e478]: "mod.callbacks.push({"
      - generic [ref=e479]: deps,
      - generic [ref=e480]: "fn: callback"
      - generic [ref=e481]: "}), this.hmrClient.hotModulesMap.set(this.ownerPath, mod);"
      - generic [ref=e482]: "}"
      - generic [ref=e483]: "}"
      - generic [ref=e484]: "class HMRClient {"
      - generic [ref=e485]: "constructor(logger, transport, importUpdatedModule) {"
      - generic [ref=e486]: this.logger = logger, this.transport = transport, this.importUpdatedModule = importUpdatedModule;
      - generic [ref=e487]: "}"
      - generic [ref=e488]: hotModulesMap = /* @__PURE__ */ new Map();
      - generic [ref=e489]: disposeMap = /* @__PURE__ */ new Map();
      - generic [ref=e490]: pruneMap = /* @__PURE__ */ new Map();
      - generic [ref=e491]: dataMap = /* @__PURE__ */ new Map();
      - generic [ref=e492]: customListenersMap = /* @__PURE__ */ new Map();
      - generic [ref=e493]: ctxToListenersMap = /* @__PURE__ */ new Map();
      - generic [ref=e494]: currentFirstInvalidatedBy;
      - generic [ref=e495]: "async notifyListeners(event, data) {"
      - generic [ref=e496]: const cbs = this.customListenersMap.get(event);
      - generic [ref=e497]: cbs && await Promise.allSettled(cbs.map((cb) => cb(data)));
      - generic [ref=e498]: "}"
      - generic [ref=e499]: "send(payload) {"
      - generic [ref=e500]: "this.transport.send(payload).catch((err) => {"
      - generic [ref=e501]: this.logger.error(err);
      - generic [ref=e502]: "});"
      - generic [ref=e503]: "}"
      - generic [ref=e504]: "clear() {"
      - generic [ref=e505]: this.hotModulesMap.clear(), this.disposeMap.clear(), this.pruneMap.clear(), this.dataMap.clear(), this.customListenersMap.clear(), this.ctxToListenersMap.clear();
      - generic [ref=e506]: "}"
      - generic [ref=e507]: // After an HMR update, some modules are no longer imported on the page
      - generic [ref=e508]: // but they may have left behind side effects that need to be cleaned up
      - generic [ref=e509]: // (e.g. style injections)
      - generic [ref=e510]: "async prunePaths(paths) {"
      - generic [ref=e511]: await Promise.all(
      - generic [ref=e512]: "paths.map((path) => {"
      - generic [ref=e513]: const disposer = this.disposeMap.get(path);
      - generic [ref=e514]: if (disposer) return disposer(this.dataMap.get(path));
      - generic [ref=e515]: "})"
      - generic [ref=e516]: "), paths.forEach((path) => {"
      - generic [ref=e517]: const fn = this.pruneMap.get(path);
      - generic [ref=e518]: fn && fn(this.dataMap.get(path));
      - generic [ref=e519]: "});"
      - generic [ref=e520]: "}"
      - generic [ref=e521]: "warnFailedUpdate(err, path) {"
      - generic [ref=e522]: (!(err instanceof Error) || !err.message.includes("fetch")) && this.logger.error(err), this.logger.error(
      - generic [ref=e523]: "`Failed to reload ${path}. This could be due to syntax errors or importing non-existent modules. (see errors above)`"
      - generic [ref=e524]: );
      - generic [ref=e525]: "}"
      - generic [ref=e526]: updateQueue = [];
      - generic [ref=e527]: pendingUpdateQueue = !1;
      - generic [ref=e528]: /**
      - generic [ref=e529]: "* buffer multiple hot updates triggered by the same src change"
      - generic [ref=e530]: "* so that they are invoked in the same order they were sent."
      - generic [ref=e531]: "* (otherwise the order may be inconsistent because of the http request round trip)"
      - generic [ref=e532]: "*/"
      - generic [ref=e533]: "async queueUpdate(payload) {"
      - generic [ref=e534]: "if (this.updateQueue.push(this.fetchUpdate(payload)), !this.pendingUpdateQueue) {"
      - generic [ref=e535]: this.pendingUpdateQueue = !0, await Promise.resolve(), this.pendingUpdateQueue = !1;
      - generic [ref=e536]: const loading = [...this.updateQueue];
      - generic [ref=e537]: this.updateQueue = [], (await Promise.all(loading)).forEach((fn) => fn && fn());
      - generic [ref=e538]: "}"
      - generic [ref=e539]: "}"
      - generic [ref=e540]: "async fetchUpdate(update) {"
      - generic [ref=e541]: "const { path, acceptedPath, firstInvalidatedBy } = update, mod = this.hotModulesMap.get(path);"
      - generic [ref=e542]: if (!mod)
      - generic [ref=e543]: return;
      - generic [ref=e544]: let fetchedModule;
      - generic [ref=e545]: const isSelfUpdate = path === acceptedPath, qualifiedCallbacks = mod.callbacks.filter(
      - generic [ref=e546]: "({ deps }) => deps.includes(acceptedPath)"
      - generic [ref=e547]: );
      - generic [ref=e548]: "if (isSelfUpdate || qualifiedCallbacks.length > 0) {"
      - generic [ref=e549]: const disposer = this.disposeMap.get(acceptedPath);
      - generic [ref=e550]: disposer && await disposer(this.dataMap.get(acceptedPath));
      - generic [ref=e551]: "try {"
      - generic [ref=e552]: fetchedModule = await this.importUpdatedModule(update);
      - generic [ref=e553]: "} catch (e) {"
      - generic [ref=e554]: this.warnFailedUpdate(e, acceptedPath);
      - generic [ref=e555]: "}"
      - generic [ref=e556]: "}"
      - generic [ref=e557]: "return () => {"
      - generic [ref=e558]: "try {"
      - generic [ref=e559]: this.currentFirstInvalidatedBy = firstInvalidatedBy;
      - generic [ref=e560]: "for (const { deps, fn } of qualifiedCallbacks)"
      - generic [ref=e561]: fn(
      - generic [ref=e562]: deps.map(
      - generic [ref=e563]: "(dep) => dep === acceptedPath ? fetchedModule : void 0"
      - generic [ref=e564]: )
      - generic [ref=e565]: );
      - generic [ref=e566]: "const loggedPath = isSelfUpdate ? path : `${acceptedPath} via ${path}`;"
      - generic [ref=e567]: "this.logger.debug(`hot updated: ${loggedPath}`);"
      - generic [ref=e568]: "} finally {"
      - generic [ref=e569]: this.currentFirstInvalidatedBy = void 0;
      - generic [ref=e570]: "}"
      - generic [ref=e571]: "};"
      - generic [ref=e572]: "}"
      - generic [ref=e573]: "}"
      - generic [ref=e574]: "function analyzeImportedModDifference(mod, rawId, moduleType, metadata) {"
      - generic [ref=e575]: "if (!metadata?.isDynamicImport && metadata?.importedNames?.length) {"
      - generic [ref=e576]: const missingBindings = metadata.importedNames.filter((s) => !(s in mod));
      - generic [ref=e577]: "if (missingBindings.length) {"
      - generic [ref=e578]: const lastBinding = missingBindings[missingBindings.length - 1];
      - generic [ref=e579]: throw moduleType === "module" ? new SyntaxError(
      - generic [ref=e580]: "`[vite] The requested module '${rawId}' does not provide an export named '${lastBinding}'`"
      - generic [ref=e581]: ") : new SyntaxError(`[vite] Named export '${lastBinding}' not found. The requested module '${rawId}' is a CommonJS module, which may not support all module.exports as named exports."
      - generic [ref=e582]: "CommonJS modules can always be imported via the default export, for example using:"
      - generic [ref=e584]: "import pkg from '${rawId}';"
      - generic [ref=e585]: "const {${missingBindings.join(\", \")}} = pkg;"
      - generic [ref=e586]: "`);"
      - generic [ref=e587]: "}"
      - generic [ref=e588]: "}"
      - generic [ref=e589]: "}"
      - generic [ref=e590]: "let urlAlphabet = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\", nanoid = (size = 21) => {"
      - generic [ref=e591]: let id = "", i = size | 0;
      - generic [ref=e592]: for (; i--; )
      - generic [ref=e593]: id += urlAlphabet[Math.random() * 64 | 0];
      - generic [ref=e594]: return id;
      - generic [ref=e595]: "};"
      - generic [ref=e596]: "function reviveInvokeError(e) {"
      - generic [ref=e597]: const error = new Error(e.message || "Unknown invoke error");
      - generic [ref=e598]: "return Object.assign(error, e, {"
      - generic [ref=e599]: // pass the whole error instead of just the stacktrace
      - generic [ref=e600]: // so that it gets formatted nicely with console.log
      - generic [ref=e601]: "runnerError: new Error(\"RunnerError\")"
      - generic [ref=e602]: "}), error;"
      - generic [ref=e603]: "}"
      - generic [ref=e604]: "const createInvokeableTransport = (transport) => {"
      - generic [ref=e605]: if (transport.invoke)
      - generic [ref=e606]: "return {"
      - generic [ref=e607]: ...transport,
      - generic [ref=e608]: "async invoke(name, data) {"
      - generic [ref=e609]: "const result = await transport.invoke({"
      - generic [ref=e610]: "type: \"custom\","
      - generic [ref=e611]: "event: \"vite:invoke\","
      - generic [ref=e612]: "data: {"
      - generic [ref=e613]: "id: \"send\","
      - generic [ref=e614]: name,
      - generic [ref=e615]: data
      - generic [ref=e616]: "}"
      - generic [ref=e617]: "});"
      - generic [ref=e618]: if ("error" in result)
      - generic [ref=e619]: throw reviveInvokeError(result.error);
      - generic [ref=e620]: return result.result;
      - generic [ref=e621]: "}"
      - generic [ref=e622]: "};"
      - generic [ref=e623]: if (!transport.send || !transport.connect)
      - generic [ref=e624]: throw new Error(
      - generic [ref=e625]: "\"transport must implement send and connect when invoke is not implemented\""
      - generic [ref=e626]: );
      - generic [ref=e627]: const rpcPromises = /* @__PURE__ */ new Map();
      - generic [ref=e628]: "return {"
      - generic [ref=e629]: ...transport,
      - generic [ref=e630]: "connect({ onMessage, onDisconnection }) {"
      - generic [ref=e631]: "return transport.connect({"
      - generic [ref=e632]: "onMessage(payload) {"
      - generic [ref=e633]: "if (payload.type === \"custom\" && payload.event === \"vite:invoke\") {"
      - generic [ref=e634]: const data = payload.data;
      - generic [ref=e635]: "if (data.id.startsWith(\"response:\")) {"
      - generic [ref=e636]: const invokeId = data.id.slice(9), promise = rpcPromises.get(invokeId);
      - generic [ref=e637]: if (!promise) return;
      - generic [ref=e638]: promise.timeoutId && clearTimeout(promise.timeoutId), rpcPromises.delete(invokeId);
      - generic [ref=e639]: "const { error, result } = data.data;"
      - generic [ref=e640]: "error ? promise.reject(error) : promise.resolve(result);"
      - generic [ref=e641]: return;
      - generic [ref=e642]: "}"
      - generic [ref=e643]: "}"
      - generic [ref=e644]: onMessage(payload);
      - generic [ref=e645]: "},"
      - generic [ref=e646]: onDisconnection
      - generic [ref=e647]: "});"
      - generic [ref=e648]: "},"
      - generic [ref=e649]: "disconnect() {"
      - generic [ref=e650]: "return rpcPromises.forEach((promise) => {"
      - generic [ref=e651]: promise.reject(
      - generic [ref=e652]: new Error(
      - generic [ref=e653]: "`transport was disconnected, cannot call ${JSON.stringify(promise.name)}`"
      - generic [ref=e654]: )
      - generic [ref=e655]: );
      - generic [ref=e656]: "}), rpcPromises.clear(), transport.disconnect?.();"
      - generic [ref=e657]: "},"
      - generic [ref=e658]: "send(data) {"
      - generic [ref=e659]: return transport.send(data);
      - generic [ref=e660]: "},"
      - generic [ref=e661]: "async invoke(name, data) {"
      - generic [ref=e662]: "const promiseId = nanoid(), wrappedData = {"
      - generic [ref=e663]: "type: \"custom\","
      - generic [ref=e664]: "event: \"vite:invoke\","
      - generic [ref=e665]: "data: {"
      - generic [ref=e666]: name,
      - generic [ref=e667]: "id: `send:${promiseId}`,"
      - generic [ref=e668]: data
      - generic [ref=e669]: "}"
      - generic [ref=e670]: "}, sendPromise = transport.send(wrappedData), { promise, resolve: resolve2, reject } = promiseWithResolvers(), timeout = transport.timeout ?? 6e4;"
      - generic [ref=e671]: let timeoutId;
      - generic [ref=e672]: "timeout > 0 && (timeoutId = setTimeout(() => {"
      - generic [ref=e673]: rpcPromises.delete(promiseId), reject(
      - generic [ref=e674]: new Error(
      - generic [ref=e675]: "`transport invoke timed out after ${timeout}ms (data: ${JSON.stringify(wrappedData)})`"
      - generic [ref=e676]: )
      - generic [ref=e677]: );
      - generic [ref=e678]: "}, timeout), timeoutId?.unref?.()), rpcPromises.set(promiseId, { resolve: resolve2, reject, name, timeoutId }), sendPromise && sendPromise.catch((err) => {"
      - generic [ref=e679]: clearTimeout(timeoutId), rpcPromises.delete(promiseId), reject(err);
      - generic [ref=e680]: "});"
      - generic [ref=e681]: "try {"
      - generic [ref=e682]: return await promise;
      - generic [ref=e683]: "} catch (err) {"
      - generic [ref=e684]: throw reviveInvokeError(err);
      - generic [ref=e685]: "}"
      - generic [ref=e686]: "}"
      - generic [ref=e687]: "};"
      - generic [ref=e688]: "}, normalizeModuleRunnerTransport = (transport) => {"
      - generic [ref=e689]: const invokeableTransport = createInvokeableTransport(transport);
      - generic [ref=e690]: let isConnected = !invokeableTransport.connect, connectingPromise;
      - generic [ref=e691]: "return {"
      - generic [ref=e692]: ...transport,
      - generic [ref=e693]: "...invokeableTransport.connect ? {"
      - generic [ref=e694]: "async connect(onMessage) {"
      - generic [ref=e695]: if (isConnected) return;
      - generic [ref=e696]: "if (connectingPromise) {"
      - generic [ref=e697]: await connectingPromise;
      - generic [ref=e698]: return;
      - generic [ref=e699]: "}"
      - generic [ref=e700]: "const maybePromise = invokeableTransport.connect({"
      - generic [ref=e701]: "onMessage: onMessage ?? (() => {"
      - generic [ref=e702]: "}),"
      - generic [ref=e703]: "onDisconnection() {"
      - generic [ref=e704]: isConnected = !1;
      - generic [ref=e705]: "}"
      - generic [ref=e706]: "});"
      - generic [ref=e707]: maybePromise && (connectingPromise = maybePromise, await connectingPromise, connectingPromise = void 0), isConnected = !0;
      - generic [ref=e708]: "}"
      - generic [ref=e709]: "} : {},"
      - generic [ref=e710]: "...invokeableTransport.disconnect ? {"
      - generic [ref=e711]: "async disconnect() {"
      - generic [ref=e712]: isConnected && (connectingPromise && await connectingPromise, isConnected = !1, await invokeableTransport.disconnect());
      - generic [ref=e713]: "}"
      - generic [ref=e714]: "} : {},"
      - generic [ref=e715]: "async send(data) {"
      - generic [ref=e716]: "if (invokeableTransport.send) {"
      - generic [ref=e717]: if (!isConnected)
      - generic [ref=e718]: if (connectingPromise)
      - generic [ref=e719]: await connectingPromise;
      - generic [ref=e720]: else
      - generic [ref=e721]: throw new Error("send was called before connect");
      - generic [ref=e722]: await invokeableTransport.send(data);
      - generic [ref=e723]: "}"
      - generic [ref=e724]: "},"
      - generic [ref=e725]: "async invoke(name, data) {"
      - generic [ref=e726]: if (!isConnected)
      - generic [ref=e727]: if (connectingPromise)
      - generic [ref=e728]: await connectingPromise;
      - generic [ref=e729]: else
      - generic [ref=e730]: throw new Error("invoke was called before connect");
      - generic [ref=e731]: return invokeableTransport.invoke(name, data);
      - generic [ref=e732]: "}"
      - generic [ref=e733]: "};"
      - generic [ref=e734]: "}, createWebSocketModuleRunnerTransport = (options) => {"
      - generic [ref=e735]: const pingInterval = options.pingInterval ?? 3e4;
      - generic [ref=e736]: let ws, pingIntervalId;
      - generic [ref=e737]: "return {"
      - generic [ref=e738]: "async connect({ onMessage, onDisconnection }) {"
      - generic [ref=e739]: const socket = options.createConnection();
      - generic [ref=e740]: "socket.addEventListener(\"message\", async ({ data }) => {"
      - generic [ref=e741]: onMessage(JSON.parse(data));
      - generic [ref=e742]: "});"
      - generic [ref=e743]: let isOpened = socket.readyState === socket.OPEN;
      - generic [ref=e744]: "isOpened || await new Promise((resolve2, reject) => {"
      - generic [ref=e745]: socket.addEventListener(
      - generic [ref=e746]: "\"open\","
      - generic [ref=e747]: "() => {"
      - generic [ref=e748]: isOpened = !0, resolve2();
      - generic [ref=e749]: "},"
      - generic [ref=e750]: "{ once: !0 }"
      - generic [ref=e751]: "), socket.addEventListener(\"close\", async () => {"
      - generic [ref=e752]: "if (!isOpened) {"
      - generic [ref=e753]: reject(new Error("WebSocket closed without opened."));
      - generic [ref=e754]: return;
      - generic [ref=e755]: "}"
      - generic [ref=e756]: "onMessage({"
      - generic [ref=e757]: "type: \"custom\","
      - generic [ref=e758]: "event: \"vite:ws:disconnect\","
      - generic [ref=e759]: "data: { webSocket: socket }"
      - generic [ref=e760]: "}), onDisconnection();"
      - generic [ref=e761]: "});"
      - generic [ref=e762]: "}), onMessage({"
      - generic [ref=e763]: "type: \"custom\","
      - generic [ref=e764]: "event: \"vite:ws:connect\","
      - generic [ref=e765]: "data: { webSocket: socket }"
      - generic [ref=e766]: "}), ws = socket, pingIntervalId = setInterval(() => {"
      - generic [ref=e767]: "socket.readyState === socket.OPEN && socket.send(JSON.stringify({ type: \"ping\" }));"
      - generic [ref=e768]: "}, pingInterval);"
      - generic [ref=e769]: "},"
      - generic [ref=e770]: "disconnect() {"
      - generic [ref=e771]: clearInterval(pingIntervalId), ws?.close();
      - generic [ref=e772]: "},"
      - generic [ref=e773]: "send(data) {"
      - generic [ref=e774]: ws.send(JSON.stringify(data));
      - generic [ref=e775]: "}"
      - generic [ref=e776]: "};"
      - generic [ref=e777]: "}, ssrModuleExportsKey = \"__vite_ssr_exports__\", ssrImportKey = \"__vite_ssr_import__\", ssrDynamicImportKey = \"__vite_ssr_dynamic_import__\", ssrExportAllKey = \"__vite_ssr_exportAll__\", ssrImportMetaKey = \"__vite_ssr_import_meta__\", noop = () => {"
      - generic [ref=e778]: "}, silentConsole = {"
      - generic [ref=e779]: "debug: noop,"
      - generic [ref=e780]: "error: noop"
      - generic [ref=e781]: "}, hmrLogger = {"
      - generic [ref=e782]: "debug: (...msg) => console.log(\"[vite]\", ...msg),"
      - generic [ref=e783]: "error: (error) => console.log(\"[vite]\", error)"
      - generic [ref=e784]: "};"
      - generic [ref=e785]: "function createHMRHandler(handler) {"
      - generic [ref=e786]: const queue = new Queue();
      - generic [ref=e787]: return (payload) => queue.enqueue(() => handler(payload));
      - generic [ref=e788]: "}"
      - generic [ref=e789]: "class Queue {"
      - generic [ref=e790]: queue = [];
      - generic [ref=e791]: pending = !1;
      - generic [ref=e792]: "enqueue(promise) {"
      - generic [ref=e793]: "return new Promise((resolve2, reject) => {"
      - generic [ref=e794]: "this.queue.push({"
      - generic [ref=e795]: promise,
      - generic [ref=e796]: "resolve: resolve2,"
      - generic [ref=e797]: reject
      - generic [ref=e798]: "}), this.dequeue();"
      - generic [ref=e799]: "});"
      - generic [ref=e800]: "}"
      - generic [ref=e801]: "dequeue() {"
      - generic [ref=e802]: if (this.pending)
      - generic [ref=e803]: return !1;
      - generic [ref=e804]: const item = this.queue.shift();
      - generic [ref=e805]: "return item ? (this.pending = !0, item.promise().then(item.resolve).catch(item.reject).finally(() => {"
      - generic [ref=e806]: this.pending = !1, this.dequeue();
      - generic [ref=e807]: "}), !0) : !1;"
      - generic [ref=e808]: "}"
      - generic [ref=e809]: "}"
      - generic [ref=e810]: "function createHMRHandlerForRunner(runner) {"
      - generic [ref=e811]: "return createHMRHandler(async (payload) => {"
      - generic [ref=e812]: const hmrClient = runner.hmrClient;
      - generic [ref=e813]: if (!(!hmrClient || runner.isClosed()))
      - generic [ref=e814]: "switch (payload.type) {"
      - generic [ref=e815]: "case \"connected\":"
      - generic [ref=e816]: hmrClient.logger.debug("connected.");
      - generic [ref=e817]: break;
      - generic [ref=e818]: "case \"update\":"
      - generic [ref=e819]: await hmrClient.notifyListeners("vite:beforeUpdate", payload), await Promise.all(
      - generic [ref=e820]: "payload.updates.map(async (update) => {"
      - generic [ref=e821]: if (update.type === "js-update")
      - generic [ref=e822]: return update.acceptedPath = unwrapId(update.acceptedPath), update.path = unwrapId(update.path), hmrClient.queueUpdate(update);
      - generic [ref=e823]: hmrClient.logger.error("css hmr is not supported in runner mode.");
      - generic [ref=e824]: "})"
      - generic [ref=e825]: ), await hmrClient.notifyListeners("vite:afterUpdate", payload);
      - generic [ref=e826]: break;
      - generic [ref=e827]: "case \"custom\": {"
      - generic [ref=e828]: await hmrClient.notifyListeners(payload.event, payload.data);
      - generic [ref=e829]: break;
      - generic [ref=e830]: "}"
      - generic [ref=e831]: "case \"full-reload\": {"
      - generic [ref=e832]: "const { triggeredBy } = payload, clearEntrypointUrls = triggeredBy ? getModulesEntrypoints("
      - generic [ref=e833]: runner,
      - generic [ref=e834]: getModulesByFile(runner, slash(triggeredBy))
      - generic [ref=e835]: ") : findAllEntrypoints(runner);"
      - generic [ref=e836]: if (!clearEntrypointUrls.size) break;
      - generic [ref=e837]: hmrClient.logger.debug("program reload"), await hmrClient.notifyListeners("vite:beforeFullReload", payload), runner.evaluatedModules.clear();
      - generic [ref=e838]: for (const url of clearEntrypointUrls)
      - generic [ref=e839]: "try {"
      - generic [ref=e840]: await runner.import(url);
      - generic [ref=e841]: "} catch (err) {"
      - generic [ref=e842]: err.code !== ERR_OUTDATED_OPTIMIZED_DEP && hmrClient.logger.error(
      - generic [ref=e843]: "`An error happened during full reload"
      - generic [ref=e844]: "${err.message}"
      - generic [ref=e845]: "${err.stack}`"
      - generic [ref=e846]: );
      - generic [ref=e847]: "}"
      - generic [ref=e848]: break;
      - generic [ref=e849]: "}"
      - generic [ref=e850]: "case \"prune\":"
      - generic [ref=e851]: await hmrClient.notifyListeners("vite:beforePrune", payload), await hmrClient.prunePaths(payload.paths);
      - generic [ref=e852]: break;
      - generic [ref=e853]: "case \"error\": {"
      - generic [ref=e854]: await hmrClient.notifyListeners("vite:error", payload);
      - generic [ref=e855]: const err = payload.err;
      - generic [ref=e856]: hmrClient.logger.error(
      - generic [ref=e857]: "`Internal Server Error"
      - generic [ref=e858]: "${err.message}"
      - generic [ref=e859]: "${err.stack}`"
      - generic [ref=e860]: );
      - generic [ref=e861]: break;
      - generic [ref=e862]: "}"
      - generic [ref=e863]: "case \"ping\":"
      - generic [ref=e864]: break;
      - generic [ref=e865]: "default:"
      - generic [ref=e866]: return payload;
      - generic [ref=e867]: "}"
      - generic [ref=e868]: "});"
      - generic [ref=e869]: "}"
      - generic [ref=e870]: "function getModulesByFile(runner, file) {"
      - generic [ref=e871]: const nodes = runner.evaluatedModules.getModulesByFile(file);
      - generic [ref=e872]: "return nodes ? [...nodes].map((node) => node.id) : [];"
      - generic [ref=e873]: "}"
      - generic [ref=e874]: "function getModulesEntrypoints(runner, modules, visited = /* @__PURE__ */ new Set(), entrypoints = /* @__PURE__ */ new Set()) {"
      - generic [ref=e875]: "for (const moduleId of modules) {"
      - generic [ref=e876]: if (visited.has(moduleId)) continue;
      - generic [ref=e877]: visited.add(moduleId);
      - generic [ref=e878]: const module = runner.evaluatedModules.getModuleById(moduleId);
      - generic [ref=e879]: "if (module) {"
      - generic [ref=e880]: "if (!module.importers.size) {"
      - generic [ref=e881]: entrypoints.add(module.url);
      - generic [ref=e882]: continue;
      - generic [ref=e883]: "}"
      - generic [ref=e884]: for (const importer of module.importers)
      - generic [ref=e885]: getModulesEntrypoints(runner, [importer], visited, entrypoints);
      - generic [ref=e886]: "}"
      - generic [ref=e887]: "}"
      - generic [ref=e888]: return entrypoints;
      - generic [ref=e889]: "}"
      - generic [ref=e890]: "function findAllEntrypoints(runner, entrypoints = /* @__PURE__ */ new Set()) {"
      - generic [ref=e891]: for (const mod of runner.evaluatedModules.idToModuleMap.values())
      - generic [ref=e892]: mod.importers.size || entrypoints.add(mod.url);
      - generic [ref=e893]: return entrypoints;
      - generic [ref=e894]: "}"
      - generic [ref=e895]: "const sourceMapCache = {}, fileContentsCache = {}, evaluatedModulesCache = /* @__PURE__ */ new Set(), retrieveFileHandlers = /* @__PURE__ */ new Set(), retrieveSourceMapHandlers = /* @__PURE__ */ new Set(), createExecHandlers = (handlers) => (...args) => {"
      - generic [ref=e896]: "for (const handler of handlers) {"
      - generic [ref=e897]: const result = handler(...args);
      - generic [ref=e898]: if (result) return result;
      - generic [ref=e899]: "}"
      - generic [ref=e900]: return null;
      - generic [ref=e901]: "}, retrieveFileFromHandlers = createExecHandlers(retrieveFileHandlers), retrieveSourceMapFromHandlers = createExecHandlers("
      - generic [ref=e902]: retrieveSourceMapHandlers
      - generic [ref=e903]: );
      - generic [ref=e904]: let overridden = !1;
      - generic [ref=e905]: const originalPrepare = Error.prepareStackTrace;
      - generic [ref=e906]: "function resetInterceptor(runner, options) {"
      - generic [ref=e907]: evaluatedModulesCache.delete(runner.evaluatedModules), options.retrieveFile && retrieveFileHandlers.delete(options.retrieveFile), options.retrieveSourceMap && retrieveSourceMapHandlers.delete(options.retrieveSourceMap), evaluatedModulesCache.size === 0 && (Error.prepareStackTrace = originalPrepare, overridden = !1);
      - generic [ref=e908]: "}"
      - generic [ref=e909]: "function interceptStackTrace(runner, options = {}) {"
      - generic [ref=e910]: return overridden || (Error.prepareStackTrace = prepareStackTrace, overridden = !0), evaluatedModulesCache.add(runner.evaluatedModules), options.retrieveFile && retrieveFileHandlers.add(options.retrieveFile), options.retrieveSourceMap && retrieveSourceMapHandlers.add(options.retrieveSourceMap), () => resetInterceptor(runner, options);
      - generic [ref=e911]: "}"
      - generic [ref=e912]: "function supportRelativeURL(file, url) {"
      - generic [ref=e913]: if (!file) return url;
      - generic [ref=e914]: const dir = posixDirname(slash(file)), match = /^\w+:\/\/[^/]*/.exec(dir);
      - generic [ref=e915]: "let protocol = match ? match[0] : \"\";"
      - generic [ref=e916]: const startPath = dir.slice(protocol.length);
      - generic [ref=e917]: "return protocol && /^\\/\\w:/.test(startPath) ? (protocol += \"/\", protocol + slash(posixResolve(startPath, url))) : protocol + posixResolve(startPath, url);"
      - generic [ref=e918]: "}"
      - generic [ref=e919]: "function getRunnerSourceMap(position) {"
      - generic [ref=e920]: "for (const moduleGraph of evaluatedModulesCache) {"
      - generic [ref=e921]: const sourceMap = moduleGraph.getModuleSourceMapById(position.source);
      - generic [ref=e922]: if (sourceMap)
      - generic [ref=e923]: "return {"
      - generic [ref=e924]: "url: position.source,"
      - generic [ref=e925]: "map: sourceMap,"
      - generic [ref=e926]: "vite: !0"
      - generic [ref=e927]: "};"
      - generic [ref=e928]: "}"
      - generic [ref=e929]: return null;
      - generic [ref=e930]: "}"
      - generic [ref=e931]: "function retrieveFile(path) {"
      - generic [ref=e932]: if (path in fileContentsCache) return fileContentsCache[path];
      - generic [ref=e933]: const content = retrieveFileFromHandlers(path);
      - generic [ref=e934]: "return typeof content == \"string\" ? (fileContentsCache[path] = content, content) : null;"
      - generic [ref=e935]: "}"
      - generic [ref=e936]: "function retrieveSourceMapURL(source) {"
      - generic [ref=e937]: const fileData = retrieveFile(source);
      - generic [ref=e938]: if (!fileData) return null;
      - generic [ref=e939]: const re = /\/\/[@#]\s*sourceMappingURL=([^\s'"]+)\s*$|\/\*[@#]\s*sourceMappingURL=[^\s*'"]+\s*\*\/\s*$/gm;
      - generic [ref=e940]: let lastMatch, match;
      - generic [ref=e941]: for (; match = re.exec(fileData); ) lastMatch = match;
      - generic [ref=e942]: "return lastMatch ? lastMatch[1] : null;"
      - generic [ref=e943]: "}"
      - generic [ref=e944]: const reSourceMap = /^data:application\/json[^,]+base64,/;
      - generic [ref=e945]: "function retrieveSourceMap(source) {"
      - generic [ref=e946]: const urlAndMap = retrieveSourceMapFromHandlers(source);
      - generic [ref=e947]: if (urlAndMap) return urlAndMap;
      - generic [ref=e948]: let sourceMappingURL = retrieveSourceMapURL(source);
      - generic [ref=e949]: if (!sourceMappingURL) return null;
      - generic [ref=e950]: let sourceMapData;
      - generic [ref=e951]: "if (reSourceMap.test(sourceMappingURL)) {"
      - generic [ref=e952]: const rawData = sourceMappingURL.slice(sourceMappingURL.indexOf(",") + 1);
      - generic [ref=e953]: sourceMapData = Buffer.from(rawData, "base64").toString(), sourceMappingURL = source;
      - generic [ref=e954]: "} else"
      - generic [ref=e955]: sourceMappingURL = supportRelativeURL(source, sourceMappingURL), sourceMapData = retrieveFile(sourceMappingURL);
      - generic [ref=e956]: "return sourceMapData ? {"
      - generic [ref=e957]: "url: sourceMappingURL,"
      - generic [ref=e958]: "map: sourceMapData"
      - generic [ref=e959]: "} : null;"
      - generic [ref=e960]: "}"
      - generic [ref=e961]: "function mapSourcePosition(position) {"
      - generic [ref=e962]: if (!position.source) return position;
      - generic [ref=e963]: let sourceMap = getRunnerSourceMap(position);
      - generic [ref=e964]: "if (sourceMap || (sourceMap = sourceMapCache[position.source]), !sourceMap) {"
      - generic [ref=e965]: const urlAndMap = retrieveSourceMap(position.source);
      - generic [ref=e966]: "if (urlAndMap && urlAndMap.map) {"
      - generic [ref=e967]: const url = urlAndMap.url;
      - generic [ref=e968]: "sourceMap = sourceMapCache[position.source] = {"
      - generic [ref=e969]: url,
      - generic [ref=e970]: "map: new DecodedMap("
      - generic [ref=e971]: "typeof urlAndMap.map == \"string\" ? JSON.parse(urlAndMap.map) : urlAndMap.map,"
      - generic [ref=e972]: url
      - generic [ref=e973]: )
      - generic [ref=e974]: "};"
      - generic [ref=e975]: const contents = sourceMap.map?.map.sourcesContent;
      - generic [ref=e976]: "sourceMap.map && contents && sourceMap.map.resolvedSources.forEach((source, i) => {"
      - generic [ref=e977]: const content = contents[i];
      - generic [ref=e978]: "if (content && source && url) {"
      - generic [ref=e979]: const contentUrl = supportRelativeURL(url, source);
      - generic [ref=e980]: fileContentsCache[contentUrl] = content;
      - generic [ref=e981]: "}"
      - generic [ref=e982]: "});"
      - generic [ref=e983]: "} else"
      - generic [ref=e984]: "sourceMap = sourceMapCache[position.source] = {"
      - generic [ref=e985]: "url: null,"
      - generic [ref=e986]: "map: null"
      - generic [ref=e987]: "};"
      - generic [ref=e988]: "}"
      - generic [ref=e989]: "if (sourceMap.map && sourceMap.url) {"
      - generic [ref=e990]: const originalPosition = getOriginalPosition(sourceMap.map, position);
      - generic [ref=e991]: if (originalPosition && originalPosition.source != null)
      - generic [ref=e992]: return originalPosition.source = supportRelativeURL(
      - generic [ref=e993]: sourceMap.url,
      - generic [ref=e994]: originalPosition.source
      - generic [ref=e995]: ), sourceMap.vite && (originalPosition._vite = !0), originalPosition;
      - generic [ref=e996]: "}"
      - generic [ref=e997]: return position;
      - generic [ref=e998]: "}"
      - generic [ref=e999]: "function mapEvalOrigin(origin) {"
      - generic [ref=e1000]: let match = /^eval at ([^(]+) \((.+):(\d+):(\d+)\)$/.exec(origin);
      - generic [ref=e1001]: "if (match) {"
      - generic [ref=e1002]: "const position = mapSourcePosition({"
      - generic [ref=e1003]: "name: null,"
      - generic [ref=e1004]: "source: match[2],"
      - generic [ref=e1005]: "line: +match[3],"
      - generic [ref=e1006]: "column: +match[4] - 1"
      - generic [ref=e1007]: "});"
      - generic [ref=e1008]: "return `eval at ${match[1]} (${position.source}:${position.line}:${position.column + 1})`;"
      - generic [ref=e1009]: "}"
      - generic [ref=e1010]: "return match = /^eval at ([^(]+) \\((.+)\\)$/.exec(origin), match ? `eval at ${match[1]} (${mapEvalOrigin(match[2])})` : origin;"
      - generic [ref=e1011]: "}"
      - generic [ref=e1012]: "function CallSiteToString() {"
      - generic [ref=e1013]: let fileName, fileLocation = "";
      - generic [ref=e1014]: if (this.isNative())
      - generic [ref=e1015]: fileLocation = "native";
      - generic [ref=e1016]: "else {"
      - generic [ref=e1017]: "fileName = this.getScriptNameOrSourceURL(), !fileName && this.isEval() && (fileLocation = this.getEvalOrigin(), fileLocation += \", \"), fileName ? fileLocation += fileName : fileLocation += \"<anonymous>\";"
      - generic [ref=e1018]: const lineNumber = this.getLineNumber();
      - generic [ref=e1019]: "if (lineNumber != null) {"
      - generic [ref=e1020]: "fileLocation += `:${lineNumber}`;"
      - generic [ref=e1021]: const columnNumber = this.getColumnNumber();
      - generic [ref=e1022]: "columnNumber && (fileLocation += `:${columnNumber}`);"
      - generic [ref=e1023]: "}"
      - generic [ref=e1024]: "}"
      - generic [ref=e1025]: let line = "";
      - generic [ref=e1026]: const functionName = this.getFunctionName();
      - generic [ref=e1027]: let addSuffix = !0;
      - generic [ref=e1028]: const isConstructor = this.isConstructor();
      - generic [ref=e1029]: if (this.isToplevel() || isConstructor)
      - generic [ref=e1030]: "isConstructor ? line += `new ${functionName || \"<anonymous>\"}` : functionName ? line += functionName : (line += fileLocation, addSuffix = !1);"
      - generic [ref=e1031]: "else {"
      - generic [ref=e1032]: let typeName = this.getTypeName();
      - generic [ref=e1033]: typeName === "[object Object]" && (typeName = "null");
      - generic [ref=e1034]: const methodName = this.getMethodName();
      - generic [ref=e1035]: "functionName ? (typeName && functionName.indexOf(typeName) !== 0 && (line += `${typeName}.`), line += functionName, methodName && functionName.indexOf(`.${methodName}`) !== functionName.length - methodName.length - 1 && (line += ` [as ${methodName}]`)) : line += `${typeName}.${methodName || \"<anonymous>\"}`;"
      - generic [ref=e1036]: "}"
      - generic [ref=e1037]: "return addSuffix && (line += ` (${fileLocation})`), line;"
      - generic [ref=e1038]: "}"
      - generic [ref=e1039]: "function cloneCallSite(frame) {"
      - generic [ref=e1040]: "const object = {};"
      - generic [ref=e1041]: "return Object.getOwnPropertyNames(Object.getPrototypeOf(frame)).forEach((name) => {"
      - generic [ref=e1042]: const key = name;
      - generic [ref=e1043]: "object[key] = /^(?:is|get)/.test(name) ? function() {"
      - generic [ref=e1044]: return frame[key].call(frame);
      - generic [ref=e1045]: "} : frame[key];"
      - generic [ref=e1046]: "}), object.toString = CallSiteToString, object;"
      - generic [ref=e1047]: "}"
      - generic [ref=e1048]: "function wrapCallSite(frame, state) {"
      - generic [ref=e1049]: "if (state === void 0 && (state = { nextPosition: null, curPosition: null }), frame.isNative())"
      - generic [ref=e1050]: return state.curPosition = null, frame;
      - generic [ref=e1051]: const source = frame.getFileName() || frame.getScriptNameOrSourceURL();
      - generic [ref=e1052]: "if (source) {"
      - generic [ref=e1053]: const line = frame.getLineNumber();
      - generic [ref=e1054]: let column = frame.getColumnNumber() - 1;
      - generic [ref=e1055]: const headerLength = 62;
      - generic [ref=e1056]: line === 1 && column > headerLength && !frame.isEval() && (column -= headerLength);
      - generic [ref=e1057]: "const position = mapSourcePosition({"
      - generic [ref=e1058]: "name: null,"
      - generic [ref=e1059]: source,
      - generic [ref=e1060]: line,
      - generic [ref=e1061]: column
      - generic [ref=e1062]: "});"
      - generic [ref=e1063]: state.curPosition = position, frame = cloneCallSite(frame);
      - generic [ref=e1064]: const originalFunctionName = frame.getFunctionName;
      - generic [ref=e1065]: "return frame.getFunctionName = function() {"
      - generic [ref=e1066]: "const name = state.nextPosition == null ? originalFunctionName() : state.nextPosition.name || originalFunctionName();"
      - generic [ref=e1067]: "return name === \"eval\" && \"_vite\" in position ? null : name;"
      - generic [ref=e1068]: "}, frame.getFileName = function() {"
      - generic [ref=e1069]: return position.source ?? void 0;
      - generic [ref=e1070]: "}, frame.getLineNumber = function() {"
      - generic [ref=e1071]: return position.line;
      - generic [ref=e1072]: "}, frame.getColumnNumber = function() {"
      - generic [ref=e1073]: return position.column + 1;
      - generic [ref=e1074]: "}, frame.getScriptNameOrSourceURL = function() {"
      - generic [ref=e1075]: return position.source;
      - generic [ref=e1076]: "}, frame;"
      - generic [ref=e1077]: "}"
      - generic [ref=e1078]: let origin = frame.isEval() && frame.getEvalOrigin();
      - generic [ref=e1079]: "return origin && (origin = mapEvalOrigin(origin), frame = cloneCallSite(frame), frame.getEvalOrigin = function() {"
      - generic [ref=e1080]: return origin || void 0;
      - generic [ref=e1081]: "}), frame;"
      - generic [ref=e1082]: "}"
      - generic [ref=e1083]: "function prepareStackTrace(error, stack) {"
      - generic [ref=e1084]: "const name = error.name || \"Error\", message = error.message || \"\", errorString = `${name}: ${message}`, state = { nextPosition: null, curPosition: null }, processedStack = [];"
      - generic [ref=e1085]: for (let i = stack.length - 1; i >= 0; i--)
      - generic [ref=e1086]: "processedStack.push(`"
      - generic [ref=e1087]: "at ${wrapCallSite(stack[i], state)}`), state.nextPosition = state.curPosition;"
      - generic [ref=e1088]: return state.curPosition = state.nextPosition = null, errorString + processedStack.reverse().join("");
      - generic [ref=e1089]: "}"
      - generic [ref=e1090]: "function enableSourceMapSupport(runner) {"
      - generic [ref=e1091]: "if (runner.options.sourcemapInterceptor === \"node\") {"
      - generic [ref=e1092]: if (typeof process > "u")
      - generic [ref=e1093]: throw new TypeError(
      - generic [ref=e1094]: "`Cannot use \"sourcemapInterceptor: 'node'\" because global \"process\" variable is not available.`"
      - generic [ref=e1095]: );
      - generic [ref=e1096]: if (typeof process.setSourceMapsEnabled != "function")
      - generic [ref=e1097]: throw new TypeError(
      - generic [ref=e1098]: "`Cannot use \"sourcemapInterceptor: 'node'\" because \"process.setSourceMapsEnabled\" function is not available. Please use Node >= 16.6.0.`"
      - generic [ref=e1099]: );
      - generic [ref=e1100]: const isEnabledAlready = process.sourceMapsEnabled ?? !1;
      - generic [ref=e1101]: return process.setSourceMapsEnabled(!0), () => !isEnabledAlready && process.setSourceMapsEnabled(!1);
      - generic [ref=e1102]: "}"
      - generic [ref=e1103]: return interceptStackTrace(
      - generic [ref=e1104]: runner,
      - generic [ref=e1105]: "typeof runner.options.sourcemapInterceptor == \"object\" ? runner.options.sourcemapInterceptor : void 0"
      - generic [ref=e1106]: );
      - generic [ref=e1107]: "}"
      - generic [ref=e1108]: "class ESModulesEvaluator {"
      - generic [ref=e1109]: startOffset = getAsyncFunctionDeclarationPaddingLineCount();
      - generic [ref=e1110]: "async runInlinedModule(context, code) {"
      - generic [ref=e1111]: await new AsyncFunction(
      - generic [ref=e1112]: ssrModuleExportsKey,
      - generic [ref=e1113]: ssrImportMetaKey,
      - generic [ref=e1114]: ssrImportKey,
      - generic [ref=e1115]: ssrDynamicImportKey,
      - generic [ref=e1116]: ssrExportAllKey,
      - generic [ref=e1117]: // source map should already be inlined by Vite
      - generic [ref=e1118]: "'\"use strict\";' + code"
      - generic [ref=e1119]: )(
      - generic [ref=e1120]: ^
      - generic [ref=e1121]: context[ssrModuleExportsKey],
      - generic [ref=e1122]: context[ssrImportMetaKey],
      - generic [ref=e1123]: context[ssrImportKey],
      - generic [ref=e1124]: context[ssrDynamicImportKey],
      - generic [ref=e1125]: context[ssrExportAllKey]
      - generic [ref=e1126]: ), Object.seal(context[ssrModuleExportsKey]);
      - generic [ref=e1127]: "}"
      - generic [ref=e1128]: "runExternalModule(filepath) {"
      - generic [ref=e1129]: return import(filepath);
      - generic [ref=e1130]: "}"
      - generic [ref=e1131]: "}"
      - generic [ref=e1132]: "class ModuleRunner {"
      - generic [ref=e1133]: "constructor(options, evaluator = new ESModulesEvaluator(), debug) {"
      - generic [ref=e1134]: "if (this.options = options, this.evaluator = evaluator, this.debug = debug, this.evaluatedModules = options.evaluatedModules ?? new EvaluatedModules(), this.transport = normalizeModuleRunnerTransport(options.transport), options.hmr !== !1) {"
      - generic [ref=e1135]: "const optionsHmr = options.hmr ?? !0, resolvedHmrLogger = optionsHmr === !0 || optionsHmr.logger === void 0 ? hmrLogger : optionsHmr.logger === !1 ? silentConsole : optionsHmr.logger;"
      - generic [ref=e1136]: if (this.hmrClient = new HMRClient(
      - generic [ref=e1137]: resolvedHmrLogger,
      - generic [ref=e1138]: this.transport,
      - generic [ref=e1139]: "({ acceptedPath }) => this.import(acceptedPath)"
      - generic [ref=e1140]: ), !this.transport.connect)
      - generic [ref=e1141]: throw new Error(
      - generic [ref=e1142]: "\"HMR is not supported by this runner transport, but `hmr` option was set to true\""
      - generic [ref=e1143]: );
      - generic [ref=e1144]: this.transport.connect(createHMRHandlerForRunner(this));
      - generic [ref=e1145]: "} else"
      - generic [ref=e1146]: this.transport.connect?.();
      - generic [ref=e1147]: options.sourcemapInterceptor !== !1 && (this.resetSourceMapSupport = enableSourceMapSupport(this));
      - generic [ref=e1148]: "}"
      - generic [ref=e1149]: evaluatedModules;
      - generic [ref=e1150]: hmrClient;
      - generic [ref=e1151]: "envProxy = new Proxy({}, {"
      - generic [ref=e1152]: "get(_, p) {"
      - generic [ref=e1153]: throw new Error(
      - generic [ref=e1154]: "`[module runner] Dynamic access of \"import.meta.env\" is not supported. Please, use \"import.meta.env.${String(p)}\" instead.`"
      - generic [ref=e1155]: );
      - generic [ref=e1156]: "}"
      - generic [ref=e1157]: "});"
      - generic [ref=e1158]: transport;
      - generic [ref=e1159]: resetSourceMapSupport;
      - generic [ref=e1160]: concurrentModuleNodePromises = /* @__PURE__ */ new Map();
      - generic [ref=e1161]: closed = !1;
      - generic [ref=e1162]: /**
      - generic [ref=e1163]: "* URL to execute. Accepts file path, server path or id relative to the root."
      - generic [ref=e1164]: "*/"
      - generic [ref=e1165]: "async import(url) {"
      - generic [ref=e1166]: const fetchedModule = await this.cachedModule(url);
      - generic [ref=e1167]: return await this.cachedRequest(url, fetchedModule);
      - generic [ref=e1168]: "}"
      - generic [ref=e1169]: /**
      - generic [ref=e1170]: "* Clear all caches including HMR listeners."
      - generic [ref=e1171]: "*/"
      - generic [ref=e1172]: "clearCache() {"
      - generic [ref=e1173]: this.evaluatedModules.clear(), this.hmrClient?.clear();
      - generic [ref=e1174]: "}"
      - generic [ref=e1175]: /**
      - generic [ref=e1176]: "* Clears all caches, removes all HMR listeners, and resets source map support."
      - generic [ref=e1177]: "* This method doesn't stop the HMR connection."
      - generic [ref=e1178]: "*/"
      - generic [ref=e1179]: "async close() {"
      - generic [ref=e1180]: this.resetSourceMapSupport?.(), this.clearCache(), this.hmrClient = void 0, this.closed = !0, await this.transport.disconnect?.();
      - generic [ref=e1181]: "}"
      - generic [ref=e1182]: /**
      - generic [ref=e1183]: "* Returns `true` if the runtime has been closed by calling `close()` method."
      - generic [ref=e1184]: "*/"
      - generic [ref=e1185]: "isClosed() {"
      - generic [ref=e1186]: return this.closed;
      - generic [ref=e1187]: "}"
      - generic [ref=e1188]: "processImport(exports, fetchResult, metadata) {"
      - generic [ref=e1189]: if (!("externalize" in fetchResult))
      - generic [ref=e1190]: return exports;
      - generic [ref=e1191]: "const { url, type } = fetchResult;"
      - generic [ref=e1192]: return type !== "module" && type !== "commonjs" || analyzeImportedModDifference(exports, url, type, metadata), exports;
      - generic [ref=e1193]: "}"
      - generic [ref=e1194]: "isCircularModule(mod) {"
      - generic [ref=e1195]: for (const importedFile of mod.imports)
      - generic [ref=e1196]: if (mod.importers.has(importedFile))
      - generic [ref=e1197]: return !0;
      - generic [ref=e1198]: return !1;
      - generic [ref=e1199]: "}"
      - generic [ref=e1200]: "isCircularImport(importers, moduleUrl, visited = /* @__PURE__ */ new Set()) {"
      - generic [ref=e1201]: "for (const importer of importers) {"
      - generic [ref=e1202]: if (visited.has(importer))
      - generic [ref=e1203]: continue;
      - generic [ref=e1204]: if (visited.add(importer), importer === moduleUrl)
      - generic [ref=e1205]: return !0;
      - generic [ref=e1206]: const mod = this.evaluatedModules.getModuleById(importer);
      - generic [ref=e1207]: if (mod && mod.importers.size && this.isCircularImport(mod.importers, moduleUrl, visited))
      - generic [ref=e1208]: return !0;
      - generic [ref=e1209]: "}"
      - generic [ref=e1210]: return !1;
      - generic [ref=e1211]: "}"
      - generic [ref=e1212]: "async cachedRequest(url, mod, callstack = [], metadata) {"
      - generic [ref=e1213]: "const meta = mod.meta, moduleId = meta.id, { importers } = mod, importee = callstack[callstack.length - 1];"
      - generic [ref=e1214]: if (importee && importers.add(importee), (callstack.includes(moduleId) || this.isCircularModule(mod) || this.isCircularImport(importers, moduleId)) && mod.exports)
      - generic [ref=e1215]: return this.processImport(mod.exports, meta, metadata);
      - generic [ref=e1216]: let debugTimer;
      - generic [ref=e1217]: "this.debug && (debugTimer = setTimeout(() => {"
      - generic [ref=e1218]: "const getStack = () => `stack:"
      - generic [ref=e1219]: "${[...callstack, moduleId].reverse().map((p) => ` - ${p}`).join(`"
      - generic [ref=e1220]: "`)}`;"
      - generic [ref=e1221]: this.debug(
      - generic [ref=e1222]: "`[module runner] module ${moduleId} takes over 2s to load."
      - generic [ref=e1223]: "${getStack()}`"
      - generic [ref=e1224]: );
      - generic [ref=e1225]: "}, 2e3));"
      - generic [ref=e1226]: "try {"
      - generic [ref=e1227]: if (mod.promise)
      - generic [ref=e1228]: return this.processImport(await mod.promise, meta, metadata);
      - generic [ref=e1229]: const promise = this.directRequest(url, mod, callstack);
      - generic [ref=e1230]: return mod.promise = promise, mod.evaluated = !1, this.processImport(await promise, meta, metadata);
      - generic [ref=e1231]: "} finally {"
      - generic [ref=e1232]: mod.evaluated = !0, debugTimer && clearTimeout(debugTimer);
      - generic [ref=e1233]: "}"
      - generic [ref=e1234]: "}"
      - generic [ref=e1235]: "async cachedModule(url, importer) {"
      - generic [ref=e1236]: let cached = this.concurrentModuleNodePromises.get(url);
      - generic [ref=e1237]: if (cached)
      - generic [ref=e1238]: this.debug?.("[module runner] using cached module info for", url);
      - generic [ref=e1239]: "else {"
      - generic [ref=e1240]: const cachedModule = this.evaluatedModules.getModuleByUrl(url);
      - generic [ref=e1241]: cached = this.getModuleInformation(url, importer, cachedModule).finally(
      - generic [ref=e1242]: "() => {"
      - generic [ref=e1243]: this.concurrentModuleNodePromises.delete(url);
      - generic [ref=e1244]: "}"
      - generic [ref=e1245]: ), this.concurrentModuleNodePromises.set(url, cached);
      - generic [ref=e1246]: "}"
      - generic [ref=e1247]: return cached;
      - generic [ref=e1248]: "}"
      - generic [ref=e1249]: "async getModuleInformation(url, importer, cachedModule) {"
      - generic [ref=e1250]: if (this.closed)
      - generic [ref=e1251]: throw new Error("Vite module runner has been closed.");
      - generic [ref=e1252]: this.debug?.("[module runner] fetching", url);
      - generic [ref=e1253]: const isCached = !!(typeof cachedModule == "object" && cachedModule.meta), fetchedModule = (
      - generic [ref=e1254]: // fast return for established externalized pattern
      - generic [ref=e1255]: "url.startsWith(\"data:\") ? { externalize: url, type: \"builtin\" } : await this.transport.invoke(\"fetchModule\", ["
      - generic [ref=e1256]: url,
      - generic [ref=e1257]: importer,
      - generic [ref=e1258]: "{"
      - generic [ref=e1259]: "cached: isCached,"
      - generic [ref=e1260]: "startOffset: this.evaluator.startOffset"
      - generic [ref=e1261]: "}"
      - generic [ref=e1262]: "])"
      - generic [ref=e1263]: );
      - generic [ref=e1264]: "if (\"cache\" in fetchedModule) {"
      - generic [ref=e1265]: if (!cachedModule || !cachedModule.meta)
      - generic [ref=e1266]: throw new Error(
      - generic [ref=e1267]: "`Module \"${url}\" was mistakenly invalidated during fetch phase.`"
      - generic [ref=e1268]: );
      - generic [ref=e1269]: return cachedModule;
      - generic [ref=e1270]: "}"
      - generic [ref=e1271]: "const moduleId = \"externalize\" in fetchedModule ? fetchedModule.externalize : fetchedModule.id, moduleUrl = \"url\" in fetchedModule ? fetchedModule.url : url, module = this.evaluatedModules.ensureModule(moduleId, moduleUrl);"
      - generic [ref=e1272]: return "invalidate" in fetchedModule && fetchedModule.invalidate && this.evaluatedModules.invalidateModule(module), fetchedModule.url = moduleUrl, fetchedModule.id = moduleId, module.meta = fetchedModule, module;
      - generic [ref=e1273]: "}"
      - generic [ref=e1274]: // override is allowed, consider this a public API
      - generic [ref=e1275]: "async directRequest(url, mod, _callstack) {"
      - generic [ref=e1276]: "const fetchResult = mod.meta, moduleId = fetchResult.id, callstack = [..._callstack, moduleId], request = async (dep, metadata) => {"
      - generic [ref=e1277]: const importer = "file" in fetchResult && fetchResult.file || moduleId, depMod = await this.cachedModule(dep, importer);
      - generic [ref=e1278]: return depMod.importers.add(moduleId), mod.imports.add(depMod.id), this.cachedRequest(dep, depMod, callstack, metadata);
      - generic [ref=e1279]: "}, dynamicRequest = async (dep) => (dep = String(dep), dep[0] === \".\" && (dep = posixResolve(posixDirname(url), dep)), request(dep, { isDynamicImport: !0 }));"
      - generic [ref=e1280]: "if (\"externalize\" in fetchResult) {"
      - generic [ref=e1281]: "const { externalize } = fetchResult;"
      - generic [ref=e1282]: this.debug?.("[module runner] externalizing", externalize);
      - generic [ref=e1283]: const exports2 = await this.evaluator.runExternalModule(externalize);
      - generic [ref=e1284]: return mod.exports = exports2, exports2;
      - generic [ref=e1285]: "}"
      - generic [ref=e1286]: "const { code, file } = fetchResult;"
      - generic [ref=e1287]: "if (code == null) {"
      - generic [ref=e1288]: const importer = callstack[callstack.length - 2];
      - generic [ref=e1289]: throw new Error(
      - generic [ref=e1290]: "`[module runner] Failed to load \"${url}\"${importer ? ` imported from ${importer}` : \"\"}`"
      - generic [ref=e1291]: );
      - generic [ref=e1292]: "}"
      - generic [ref=e1293]: "const modulePath = cleanUrl(file || moduleId), href = posixPathToFileHref(modulePath), filename = modulePath, dirname2 = posixDirname(modulePath), meta = {"
      - generic [ref=e1294]: "filename: isWindows ? toWindowsPath(filename) : filename,"
      - generic [ref=e1295]: "dirname: isWindows ? toWindowsPath(dirname2) : dirname2,"
      - generic [ref=e1296]: "url: href,"
      - generic [ref=e1297]: "env: this.envProxy,"
      - generic [ref=e1298]: "resolve(_id, _parent) {"
      - generic [ref=e1299]: throw new Error(
      - generic [ref=e1300]: "'[module runner] \"import.meta.resolve\" is not supported.'"
      - generic [ref=e1301]: );
      - generic [ref=e1302]: "},"
      - generic [ref=e1303]: // should be replaced during transformation
      - generic [ref=e1304]: "glob() {"
      - generic [ref=e1305]: throw new Error(
      - generic [ref=e1306]: "'[module runner] \"import.meta.glob\" is statically replaced during file transformation. Make sure to reference it by the full name.'"
      - generic [ref=e1307]: );
      - generic [ref=e1308]: "}"
      - generic [ref=e1309]: "}, exports = /* @__PURE__ */ Object.create(null);"
      - generic [ref=e1310]: "Object.defineProperty(exports, Symbol.toStringTag, {"
      - generic [ref=e1311]: "value: \"Module\","
      - generic [ref=e1312]: "enumerable: !1,"
      - generic [ref=e1313]: "configurable: !1"
      - generic [ref=e1314]: "}), mod.exports = exports;"
      - generic [ref=e1315]: let hotContext;
      - generic [ref=e1316]: "this.hmrClient && Object.defineProperty(meta, \"hot\", {"
      - generic [ref=e1317]: "enumerable: !0,"
      - generic [ref=e1318]: "get: () => {"
      - generic [ref=e1319]: if (!this.hmrClient)
      - generic [ref=e1320]: throw new Error("[module runner] HMR client was closed.");
      - generic [ref=e1321]: return this.debug?.("[module runner] creating hmr context for", mod.url), hotContext ||= new HMRContext(this.hmrClient, mod.url), hotContext;
      - generic [ref=e1322]: "},"
      - generic [ref=e1323]: "set: (value) => {"
      - generic [ref=e1324]: hotContext = value;
      - generic [ref=e1325]: "}"
      - generic [ref=e1326]: "});"
      - generic [ref=e1327]: "const context = {"
      - generic [ref=e1328]: "[ssrImportKey]: request,"
      - generic [ref=e1329]: "[ssrDynamicImportKey]: dynamicRequest,"
      - generic [ref=e1330]: "[ssrModuleExportsKey]: exports,"
      - generic [ref=e1331]: "[ssrExportAllKey]: (obj) => exportAll(exports, obj),"
      - generic [ref=e1332]: "[ssrImportMetaKey]: meta"
      - generic [ref=e1333]: "};"
      - generic [ref=e1334]: return this.debug?.("[module runner] executing", href), await this.evaluator.runInlinedModule(context, code, mod), exports;
      - generic [ref=e1335]: "}"
      - generic [ref=e1336]: "}"
      - generic [ref=e1337]: "function exportAll(exports, sourceModule) {"
      - generic [ref=e1338]: "if (exports !== sourceModule && !(isPrimitive(sourceModule) || Array.isArray(sourceModule) || sourceModule instanceof Promise)) {"
      - generic [ref=e1339]: for (const key in sourceModule)
      - generic [ref=e1340]: if (key !== "default" && key !== "__esModule" && !(key in exports))
      - generic [ref=e1341]: "try {"
      - generic [ref=e1342]: "Object.defineProperty(exports, key, {"
      - generic [ref=e1343]: "enumerable: !0,"
      - generic [ref=e1344]: "configurable: !0,"
      - generic [ref=e1345]: "get: () => sourceModule[key]"
      - generic [ref=e1346]: "});"
      - generic [ref=e1347]: "} catch {"
      - generic [ref=e1348]: "}"
      - generic [ref=e1349]: "}"
      - generic [ref=e1350]: "}"
      - generic [ref=e1351]: "export {"
      - generic [ref=e1352]: ESModulesEvaluator,
      - generic [ref=e1353]: EvaluatedModules,
      - generic [ref=e1354]: ModuleRunner,
      - generic [ref=e1355]: createWebSocketModuleRunnerTransport,
      - generic [ref=e1356]: ssrDynamicImportKey,
      - generic [ref=e1357]: ssrExportAllKey,
      - generic [ref=e1358]: ssrImportKey,
      - generic [ref=e1359]: ssrImportMetaKey,
      - generic [ref=e1360]: ssrModuleExportsKey
      - generic [ref=e1361]: "};"
  - generic [ref=e1363]:
    - generic [ref=e1364]:
      - heading "Stack Trace" [level=2] [ref=e1365]
      - img [ref=e1367] [cursor=pointer]
    - generic [ref=e1371]: "ReferenceError: document is not defined at /home/oswald/Desktop/marki14/front/public/js/pages/sequencesState.js:6:1 at ESModulesEvaluator.runInlinedModule (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1070:6) at SSRCompatModuleRunner.directRequest (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1284:82) at SSRCompatModuleRunner.directRequest (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/chunks/dep-D4NMHUTW.js:25274:35) at SSRCompatModuleRunner.cachedRequest (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1179:28) at request (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1228:79) at async eval (/home/oswald/Desktop/marki14/front/src/pages/sequences.astro:4:1) at async ESModulesEvaluator.runInlinedModule (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1062:5) at async SSRCompatModuleRunner.directRequest (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/module-runner.js:1284:61) at async SSRCompatModuleRunner.directRequest (file:///home/oswald/Desktop/marki14/front/node_modules/vite/dist/node/chunks/dep-D4NMHUTW.js:25274:23)"
```